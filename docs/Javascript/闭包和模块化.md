---
sidebar_position: 5
---

## 闭包

闭包就是函数加自由变量。

> 所谓自由变量就是指除了全局变量和当前函数内部变量之外的变量。闭包不是函数，闭包是一种语言特性。有的语言不支持闭包，因此他的函数不能访问自由变量。

### 闭包和模块化

模块可以看作一种代码模式，本质上是利用了闭包这个概念+封装的思想。

> 《你不知道的 JavaScript（卷一）》

```js
function CoolModule() {
  var something = "cool";
  var another = [1, 2, 3];
  function doSomething() {
    console.log(something);
  }
  function doAnother() {
    console.log(another.join("!"));
  }
  return {
    doSomething: doAnother,
    doAnother: doAnother,
  };
}
var foo = CoolModule();
foo.doSomething();
foo.doAnother();
```

这个代码模式就是模块。

**CoolModule()** 只是一个函数，我们通过调用他创建了一个模块实例，也创建了内部作用域和闭包。

这里返回值可以看作**模块的公共 API**。每次调用都会创建一个新的模块实例。

当然也可以从内部对模块实例进行修改（添加、删除方法或者属性，以及修改值）。

但是这种实现模块化的方式（也就是 CommonJS）依赖的是动态加载，也就是运行时的。ES6 模块的 API 是静态的，也就是编译时（这是语言层面的，其他的模块化规范都是在上层做的）。

现在看来，模块有两个特征：

- 为创建内部作用域而调用了一个包装函数
- 包装函数的返回值必须至少包括一个对内部函数的引用，这样调用包装函数时，就会创建包含整个包装函数内部作用域的闭包

## 模块化

先说一下结论：

|          | CommonJS                                                                                   | ES Module                        |
| -------- | ------------------------------------------------------------------------------------------ | -------------------------------- |
| 值       | 基本类型：值的复制，不共享<br/>引用类型：浅拷贝                                            | 只读引用                         |
| 执行顺序 | 深度优先遍历<br/> 会检查是否有该模块的缓存，如果有就使用缓存；没有就执行该模块代码，并缓存 | 提前加载并且执行<br/> 不会做缓存 |

### CommonJS

#### 验证值

- 基本类型，不共享
- 引用类型，浅拷贝

```js
// mod.js
let count = 1;
let friends = ["夏洛"];

function plusCount() {
  count++;
}

function plusYuanhua() {
  friends.push("袁华");
}

setInterval(() => {
  console.log("mod.js 每秒打印 - count", count);
  console.log("mod.js 每秒打印 - friends", friends);
}, 1000);

module.exports = {
  count,
  friends,
  plusCount,
  plusYuanhua,
};

// index.js
const mod = require("./mod.js");

console.log("index.js 初次导入 - mod.count", mod.count);
console.log("index.js 初次导入 - mod.friends", mod.friends);

mod.plusCount();
mod.plusYuanhua();

console.log(
  "index.js 执行 mod.plusCount/plusYuanhua 后 - mod.count",
  mod.count
);
console.log(
  "index.js 执行 mod.plusCount/plusYuanhua 后 - mod.friends",
  mod.friends
);

setTimeout(() => {
  mod.count = 3;
  console.log("index.js 延时2s - mod.count", mod.count);
  console.log("index.js 延时2s - mod.friends", mod.friends);
}, 2000);

/*
index.js 初次导入 - mod.count 1
index.js 初次导入 - mod.friends [ '夏洛' ]

index.js 执行 mod.plusCount/plusYuanhua 后 - mod.count 1
index.js 执行 mod.plusCount/plusYuanhua 后 - mod.friends [ '夏洛', '袁华' ]

mod.js 每秒打印 - count 2
mod.js 每秒打印 - friends [ '夏洛', '袁华' ]

mod.js 每秒打印 - count 2
mod.js 每秒打印 - friends [ '夏洛', '袁华' ]

index.js 延时2s - mod.count 3
index.js 延时2s - mod.friends [ '夏洛', '袁华' ]

mod.js 每秒打印 - count 2
mod.js 每秒打印 - friends [ '夏洛', '袁华' ]
*/
```

#### 加载顺序

CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值。

`a.js`脚本先输出一个`done`变量，然后加载另一个脚本文件`b.js`。

**注意，此时`a.js`代码就停在这里，等待`b.js`执行完毕，再往下执行。**

`b.js`执行到第二行，就会去加载`a.js`，这时，就发生了“循环加载”。系统会去`a.js`模块对应对象的`exports`属性取值，可是因为`a.js`还没有执行完，从`exports`属性只能取回已经执行的部分，而不是最后的值。

`a.js`已经执行的部分，只有一行。

```javascript
exports.done = false;
```

因此，对于`b.js`来说，它从`a.js`只输入一个变量`done`，值为`false`。

然后，`b.js`接着往下执行，等到全部执行完毕，再把执行权交还给`a.js`。于是，`a.js`接着往下执行，直到执行完毕。

最后的结果还说明了两件事：

- 在`b.js`之中，`a.js`没有执行完毕，只执行了第一行。
- **`main.js`执行到第二行时，不会再次执行`b.js`，而是输出缓存的`b.js`的执行结果（就是在`a.js`里执行完的），** 即它的第四行。

```js
// index.js
let a = require("./modA.js");
let b = require("./modB.js");
console.log("index.js-1", "执行完毕", a.done, b.done);

// modA.js
exports.done = false;
let b = require("./modB.js");
console.log("modA.js-1", b.done);
exports.done = true;
console.log("modB.js-2", "执行完毕");

// modB.js
exports.done = false;
let a = require("./modA.js");
console.log("modB.js-1", a.done);
exports.done = true;
console.log("modB.js-2", "执行完毕");

/*
modB.js-1 false
modB.js-2 执行完毕
modA.js-1 true
modB.js-2 执行完毕
index.js-1 执行完毕 true true
*/
```

### ES Module

#### 验证值

只读引用

```js
// index.mjs
import { counter } from "./mod.mjs";
// counter = {}; // TypeError: Assignment to constant variable.
counter.count = 2;
console.log("index.js", counter);

// mod.mjs
export const counter = {
  count: 1,
};
setInterval(() => {
  console.log("mod.js", counter.count);
}, 1000);

/*
 * index.js { count: 2 }
 * mod.js 2
 * mod.js 2
 * mod.js 2
 * ...
 */
```

#### 加载顺序

CommonJS 模块同步加载并执行模块文件，ES6 模块**提前加载并执行模块文件**。异步通常被理解为延后一个时间节点执行，所以说成异步加载是错误的。

这里由于子模块先于父模块被执行，子模块直接执行从父模块导入的变量会导致 JS 错误。

`node parent.js`

```js
// 文件 parent.js
import {} from "./child.js"; // 这里就相当于提前加载
export const parent = "parent";

// 文件 child.js
import { parent } from "./parent.js";
console.log(parent); // 报错
```

如果把 ESM 理解为异步执行，则不会报错，因为异步执行的时候父模块已经被执行了，已经 export 出去 parent 变量了，然后 `import {} from "./child.js";`。

效果如下，`import {} from "./child.js";` 子模块是一个异步的效果，异步执行的时候父模块已经被执行了：

`node parent.js`

```js
// parent.js
import {} from "./child.js";
export const parent = "parent";

// child.js
import { parent } from "./parent.js";
setTimeout(() => {
  console.log(parent); // 输出 'parent'
}, 0);
```
