---
sidebar_position: 10
---

先谈一下概念，位运算直接对二进制位进行计算，处理每一个比特位，是非常底层的运算，好处是速度极快，缺点是很不直观。

需要注意的是：位运算的优先级很低，注意需要加上括号。

位运算只对整数起作用，如果一个运算数不是整数，会自动转为整数后再运行。

在 JavaScript 内部，数值都是以 64 位浮点数的形式储存，但是做位运算的时候，是**以 32 位带符号的整数进行运算**，并且返回值也是一个 32 位带符号的整数。

> 注意和逻辑运算符区分，另外**位运算是在原码的基础上操作的**

## 7 个位运算的基本用法

### 按位与(AND) `&`

`&` 的规则：对应的位都为 1，那么结果就是 1， 如果任意一个位是 0 则结果就是 0。

```
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// 3的二进制表示为: 00000000 00000000 00000000 00000011
// -----------------------------
// 1的二进制表示为: 00000000 00000000 00000000 00000001
console.log(1 & 3)     // 1
```

### 按位或(OR) `|`

`|` 的规则：任一位为 1，结果就是 1。

```
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// 3的二进制表示为: 00000000 00000000 00000000 00000011
// -----------------------------
// 3的二进制表示为: 00000000 00000000 00000000 00000011
console.log(1 | 3)     // 3
```

### 按位异或(XOR) `^`

`^` 的规则：对应的两个位有且仅有一个 1 时结果为 1，其他都是 0。

```
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// 3的二进制表示为: 00000000 00000000 00000000 00000011
// -----------------------------
// 2的二进制表示为: 00000000 00000000 00000000 00000010
console.log(1 ^ 3)     // 2
```

### 按位非(NOT) `~`

`~` 的规则是：对位求反，1 变 0, 0 变 1。

```
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// 3的二进制表示为: 00000000 00000000 00000000 00000011
// -----------------------------
// 1反码二进制表示: 11111111 11111111 11111111 11111110
// 考虑到符号位是1，所以这是个负数，计算机用补码表示负数，所以这需要看作补码，求其原码就是先减1，符号位不变取反
// -----------------------------
// 减1：                11111111 11111111 11111111 11111101
// 符号位不变取反：       10000000 00000000 00000000 00000010
// 表示为10进制加负号：-2
console.log(~ 1)     // -2
```

### 左移（Left shift）`<<`

`<<` 运算符使指定值的二进制数所有位都左移指定次数，其移动规则：丢弃高位，低位补 0 。即按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补零

```
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// -----------------------------
// 2的二进制表示为: 00000000 00000000 00000000 00000010
console.log(1 << 1)     // 2
```

### 有符号右移 `>>`

`>>` 该将数值向右移动，但保留符号位，左侧空位用符号位补齐

```
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// -----------------------------
// 0的二进制表示为: 00000000 00000000 00000000 00000000
console.log(1 >> 1)     // 0

// -3 的补码：10000000 00000000 00000000 00000011
// -3 的补码减1：10000000 00000000 00000000 00000010
// 符号位不变取反得到原码：11111111 11111111 11111111 11111101
// 原码向右移动1位：11111111 11111111 11111111 11111110
// 得到对应反码：10000000 00000000 00000000 00000001
// +1得到补码：10000000 00000000 00000000 00000010 -> -2
console.log(-3 >> 1) // -2
```

### 无符号右移 `>>>`

`>>>` 的规则是：将数值所有 32 位都向右移动，左侧空位用 0 补齐。

注意： 无符号右移会操作负数的补码对应的原码，因此结果往往很大。而该操作会将左侧空位用 0 补齐，因此结果为正数。

```
// 补码：10000000 00000000 00000000 00000010
// 补码减1：10000000 00000000 00000000 00000001
// 求反得到原码：11111111 11111111 11111111 11111110
// 无符号右移1位：01111111 11111111 11111111 11111111 // 2147483647
// -----------------------------
console.log(-2 >>> 1) // 2147483647
```

## 使用位运算

### `&` 判断奇偶

```js
// 偶数 & 1 = 0
// 奇数 & 1 = 1

console.log(7 & 1); // 1
console.log(8 & 1); // 0
```

### `~`, `>>`, `<<`, `>>>`, `|` 来取整

> 相当于 `Math.floor()` 向下取整

```js
console.log(~~11.71); // 11
console.log(11.71 >> 0); // 11
console.log(11.71 << 0); // 11
console.log(11.71 | 0); // 11
console.log(11.71 >>> 0); // 11
```

```js
// 常用判断
if (arr.indexOf(item) > -1) {
  // code
}
// 因为 ~-1 = - (-1 + 1) = 0 所以只要有值就不是 0
if (~arr.indexOf(item)) {
  // code
}
```

### `>>> 1` 取平均

对于正数取平均：

```js
(x + y) >>> 1;

(1 + 3) >>> 1; // 2
```

更一般的：

```js
(x & y) + ((x ^ y) >> 1); // 向下取整；
(x | y) - ((x ^ y) >> 1); // 向上取整；

(3 & 6) + ((3 ^ 6) >> 1); // 4
(3 | 6) - ((3 ^ 6) >> 1); // 5

(-3 & -6) + ((-3 ^ -6) >> 1); // -5
(-3 | -6) - ((-3 ^ -6) >> 1); // -4
```

### 使用 `&`, `>>`, `|` 来完成 rgb 值和 16 进制颜色值之间的转换

RGB 与十六进制之间的关系，例如我们最常见的白色 RGB 表示为 `rgb(255, 255, 255)`，十六进制表示为`#FFFFFFF`, 我们可以把十六进制颜色除 `#` 外按两位分割成一部分，即 `FF,FF,FF` 十六进制的 FF 转为十进制就是 255。

将 RGB 的 3 个数值分别转为十六进制数，然后拼接，即 `rgb(255, 255, 255) => '#' + 'FF' + 'FF' + 'FF'`。

巧妙利用左移，我们把十六进制数值部分当成一个整数，即 FFFFFF，我们可以理解为 FF0000 + FF00 + FF，如同我们上面解释，如果左移是基于十六进制计算的，则可以理解为 FF << 4，FF << 2，FF，而实际上我们转为二进制则变为 FF << 16：`x * 16^4 = x * 2 ^ 16`。

```js
/**
 * 16进制颜色值转RGB
 * @param  {String} hex 16进制颜色字符串
 * @return {String}     RGB颜色字符串
 */
function hexToRGB(hex) {
  // 0x 前缀表示16进制 0xff 表示一个十六进制数 FF
  var hexx = hex.replace("#", "0x");
  var r = hexx >> 16;
  var g = (hexx >> 8) & 0xff;
  var b = hexx & 0xff;
  return `rgb(${r}, ${g}, ${b})`;
}

/**
 * RGB颜色转16进制颜色
 * @param  {String} rgb RGB进制颜色字符串
 * @return {String}     16进制颜色字符串
 */
function RGBToHex(rgb) {
  var rgbArr = rgb.split(/[^\d]+/);
  var color = (rgbArr[1] << 16) | (rgbArr[2] << 8) | rgbArr[3];
  return "#" + color.toString(16);
}
// -------------------------------------------------
hexToRGB("#ffffff"); // 'rgb(255,255,255)'
RGBToHex("rgb(255,255,255)"); // '#ffffff'
```
