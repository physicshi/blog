---
sidebar_position: 10
---

先谈一下概念，位运算直接对二进制位进行计算，处理每一个比特位，是非常底层的运算，好处是速度极快，缺点是很不直观。

需要注意的是：位运算的优先级很低，注意需要加上括号。

位运算只对整数起作用，如果一个运算数不是整数，会自动转为整数后再运行。

在 JavaScript 内部，数值都是以 64 位浮点数的形式储存，但是做位运算的时候，是**以 32 位带符号的整数进行运算**，并且返回值也是一个 32 位带符号的整数。

> 注意和逻辑运算符区分，另外**位运算是在原码的基础上操作的**

## 7 个位运算的基本用法

### 按位与(AND) `&`

`&` 的规则：对应的位都为 1，那么结果就是 1， 如果任意一个位是 0 则结果就是 0。

```
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// 3的二进制表示为: 00000000 00000000 00000000 00000011
// -----------------------------
// 1的二进制表示为: 00000000 00000000 00000000 00000001
console.log(1 & 3)     // 1
```

### 按位或(OR) `|`

`|` 的规则：任一位为 1，结果就是 1。

```
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// 3的二进制表示为: 00000000 00000000 00000000 00000011
// -----------------------------
// 3的二进制表示为: 00000000 00000000 00000000 00000011
console.log(1 | 3)     // 3
```

### 按位异或(XOR) `^`

`^` 的规则：对应的两个位有且仅有一个 1 时结果为 1，其他都是 0。

```
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// 3的二进制表示为: 00000000 00000000 00000000 00000011
// -----------------------------
// 2的二进制表示为: 00000000 00000000 00000000 00000010
console.log(1 ^ 3)     // 2
```

### 按位非(NOT) `~`

`~` 的规则是：对位求反，1 变 0, 0 变 1。

```
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// 3的二进制表示为: 00000000 00000000 00000000 00000011
// -----------------------------
// 1反码二进制表示: 11111111 11111111 11111111 11111110
// 考虑到符号位是1，所以这是个负数，计算机用补码表示负数，所以这需要看作补码，求其原码就是先减1，符号位不变取反
// -----------------------------
// 减1：                11111111 11111111 11111111 11111101
// 符号位不变取反：       10000000 00000000 00000000 00000010
// 表示为10进制加负号：-2
console.log(~ 1)     // -2
```

### 左移（Left shift）`<<`

`<<` 运算符使指定值的二进制数所有位都左移指定次数，其移动规则：丢弃高位，低位补 0 。即按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补零

```
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// -----------------------------
// 2的二进制表示为: 00000000 00000000 00000000 00000010
console.log(1 << 1)     // 2
```

### 有符号右移 `>>`

`>>` 该将数值向右移动，但保留符号位，左侧空位用符号位补齐

```
// 1的二进制表示为: 00000000 00000000 00000000 00000001
// -----------------------------
// 0的二进制表示为: 00000000 00000000 00000000 00000000
console.log(1 >> 1)     // 0

// -3 的补码：10000000 00000000 00000000 00000011
// -3 的补码减1：10000000 00000000 00000000 00000010
// 符号位不变取反得到原码：11111111 11111111 11111111 11111101
// 原码向右移动1位：11111111 11111111 11111111 11111110
// 得到对应反码：10000000 00000000 00000000 00000001
// +1得到补码：10000000 00000000 00000000 00000010 -> -2
console.log(-3 >> 1) // -2
```

### 无符号右移 `>>>`

`>>>` 的规则是：将数值所有 32 位都向右移动，左侧空位用 0 补齐。

注意： 无符号右移会操作负数的补码对应的原码，因此结果往往很大。而该操作会将左侧空位用 0 补齐，因此结果为正数。

```
// 补码：10000000 00000000 00000000 00000010
// 补码减1：10000000 00000000 00000000 00000001
// 求反得到原码：11111111 11111111 11111111 11111110
// 无符号右移1位：01111111 11111111 11111111 11111111 // 2147483647
// -----------------------------
console.log(-2 >>> 1) // 2147483647
```

## 使用位运算

### `&` 判断奇偶

```js
// 偶数 & 1 = 0
// 奇数 & 1 = 1

console.log(7 & 1); // 1
console.log(8 & 1); // 0
```

### `~`, `>>`, `<<`, `>>>`, `|` 来取整

> 相当于 `Math.floor()` 向下取整

```js
console.log(~~11.71); // 11
console.log(11.71 >> 0); // 11
console.log(11.71 << 0); // 11
console.log(11.71 | 0); // 11
console.log(11.71 >>> 0); // 11
```

```js
// 常用判断
if (arr.indexOf(item) > -1) {
  // code
}
// 因为 ~-1 = - (-1 + 1) = 0 所以只要有值就不是 0
if (~arr.indexOf(item)) {
  // code
}
```

### `>>> 1` 取平均

对于正数取平均：

```js
(x + y) >>> 1;

(1 + 3) >>> 1; // 2
```

更一般的：

```js
(x & y) + ((x ^ y) >> 1); // 向下取整；
(x | y) - ((x ^ y) >> 1); // 向上取整；

(3 & 6) + ((3 ^ 6) >> 1); // 4
(3 | 6) - ((3 ^ 6) >> 1); // 5

(-3 & -6) + ((-3 ^ -6) >> 1); // -5
(-3 | -6) - ((-3 ^ -6) >> 1); // -4
```

### 使用 `&`, `>>`, `|` 来完成 rgb 值和 16 进制颜色值之间的转换

RGB 与十六进制之间的关系，例如我们最常见的白色 RGB 表示为 `rgb(255, 255, 255)`，十六进制表示为`#FFFFFFF`, 我们可以把十六进制颜色除 `#` 外按两位分割成一部分，即 `FF,FF,FF` 十六进制的 FF 转为十进制就是 255。

将 RGB 的 3 个数值分别转为十六进制数，然后拼接，即 `rgb(255, 255, 255) => '#' + 'FF' + 'FF' + 'FF'`。

巧妙利用左移，我们把十六进制数值部分当成一个整数，即 FFFFFF，我们可以理解为 FF0000 + FF00 + FF，如同我们上面解释，如果左移是基于十六进制计算的，则可以理解为 FF << 4，FF << 2，FF，而实际上我们转为二进制则变为 FF << 16：`x * 16^4 = x * 2 ^ 16`。

```js
/**
 * 16进制颜色值转RGB
 * @param  {String} hex 16进制颜色字符串
 * @return {String}     RGB颜色字符串
 */
function hexToRGB(hex) {
  // 0x 前缀表示16进制 0xff 表示一个十六进制数 FF
  var hexx = hex.replace("#", "0x");
  var r = hexx >> 16;
  var g = (hexx >> 8) & 0xff;
  var b = hexx & 0xff;
  return `rgb(${r}, ${g}, ${b})`;
}

/**
 * RGB颜色转16进制颜色
 * @param  {String} rgb RGB进制颜色字符串
 * @return {String}     16进制颜色字符串
 */
function RGBToHex(rgb) {
  var rgbArr = rgb.split(/[^\d]+/);
  var color = (rgbArr[1] << 16) | (rgbArr[2] << 8) | rgbArr[3];
  return "#" + color.toString(16);
}
// -------------------------------------------------
hexToRGB("#ffffff"); // 'rgb(255,255,255)'
RGBToHex("rgb(255,255,255)"); // '#ffffff'
```

## 时区

因为团队做的是一些国际项目，所以不可避免会遇到一些时区问题，这里记录一下基本知识。

### 时间戳

首先提一下时间戳，时间戳是一个数字，它代表的是从 1970 年 1 月 1 日 0 时 0 分 0 秒到现在的豪秒数，比如当前时间是 `2018-01-01 12:00:00`，那么时间戳就是 `1514792000000`。

关于时间戳，时间戳是一个自增的整数，表示从 1970 年 1 月 1 日零时整的 GMT 时区开始的那一刻，到现在的毫秒数。

所以无论在哪个时区的电脑，你拿到的时间戳都是一致的。

对于时区（Time Zone)，是地球上的区域使用同一个时间定义。1884 年在华盛顿召开国际经度会议时，为了克服时间上的混乱，规定将全球划分为 24 个时区。在中国采用首都北京的东八区（国际时+8 即 GMT+8）的时间为全国统一使用时间。

对于国际化的团队，数据库保存的一般都是 UTC-0 的时间：

1. UTC 时间(世界标准时间) 与 GMT 时间(格林威治时间)
   可以认为格林威治时间就是世界协调时间（GMT=UTC，区别在于精度，两者都是伦敦地方时），格林威治时间和 UTC 时间均用秒数来计算的。

世界标准时间 (UTC, Coordinated Universal Time) 是当今民用时间的基础。它使用一天 24 小时时间制，并结合了地球的自转时间与原子钟的高精度度量。

UTC 是一个标准，而不是一个时区。UTC 是一个全球通用的时间标准。全球各地都同意将各自的时间进行同步协调 (coordinated)，这也是 UTC 名字的来源：Universal Coordinated Time。

2. UTC 时间 与 本地时
   UTC + 时区差 ＝ 本地时间
   时区差东为正，西为负。在此，把东八区时区差记为 +0800，

UTC + (＋ 0800) = 本地（北京）时间
那么，UTC = 本地时间（北京时间)）- 0800

3. UTC 与 Unix 时间戳

在计算机中看到的 UTC 时间都是从 **1970 年 01 月 01 日 00:00:00** 开始计算秒数的。所看到的 UTC 时间那就是从 1970 年这个时间点起到具体时间共有多少秒。 这个秒数就是 Unix 时间戳。

### moment 基本使用

> 这里以 moment 为例，dayjs 也类似

```js
import moment from "moment";
const dateFormatWithTime = "YYYY-MM-DD HH:mm:ss";
const getLocalTime = (time, format) => {
  return moment
    .utc(time)
    .local()
    .format(format || dateFormatWithTime);
};
```

:::tip
`moment.unix(number)` 这里是根据 `numebr` 秒生成一个 `moment` 时间对象

`moment(number)` 这里是根据 `number` 毫秒生成一个 `moment` 时间对象

所以实现上就是

`moment(timestamp * 1000) = moment.unix(timestamp)`

比如 `moment.unix(1528519053.128)` 和 `moment(1528519053128) ` 的结果是一样的：`Sat Jun 09 2018 12:37:33 GMT+0800 (中国标准时间)`

也可以 `moment('2018-06-09 12:37:33')` 或者 `moment.utc('2018-06-09 12:37:33')` 根据时间字符串得到一个 `moment` 时间对象

`Sat Jun 09 2018 12:37:33 GMT+0800 (中国标准时间)`

得到当前的 `moment` 时间对象：`moment()`
:::

两个时间戳的差

```js
// detailMsg.expected_time 是一个时间字符串
const flag = moment(getLocalTime(detailMsg.expected_time)).diff(moment());
```

时间戳定义：0 时区 1970 年 1 月 1 日到现在的毫秒数，所以全世界同一时刻的时间戳都是一样的。

北京时间对应时间戳 = unix(0 时区对应时间的时间戳) - `8*60*60*1000`（8 小时的毫秒数）

印度时间对应时间戳 = unix(0 时区对应时间的时间戳) - `5.5*60*60*1000`（5.5 小时的毫秒数）

印度时间对应时间戳 = 北京时间对应时间戳 + `2.5*60*60*1000` （换算出来是加号）

例如：

`1970 年 1 月 1 日 0 时 0 分 0 秒（北京时间）= -28800000`

`1970 年 1 月 1 日 0 时 0 分 0 秒（印度时间）= -19800000`

实际上，只要我们传递的是一个 number 类型的时间戳，我们就不用关心时区转换。任何浏览器都可以把一个时间戳正确转换为本地时间。

## React 状态更新队列

> 关于批处理 batching，以及 react 利用批处理这个概念来处理多个状态更新

```js
import { useState } from "react";

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

点击 +3 后，并不会使得计数器增加 3，虽然 `setNumber(number+1)` 调用了三次。

首先引入快照这个概念，在一次渲染里，你的状态是一个快照，是不会改变的。这里在一次渲染里，number 始终为 0，所以这里的三次 `setNumber(number+1)` 就是三次 `setNumber(0+1)` 。

:::tip
`setNum(num+5)` 里 `number` 为 0，所以 `setNum(0+5)` 就是 `React` 将 **‘替换（replace）为 5’** 添加到更新队列

`setNum(n => n+1)` 就是 `n => n+1` 作为一个更新函数添加到更新队列中

`setNum(42)` 就是 React 将 **替换为 42** 添加到更新队列中
:::

所以在下一次渲染期间，React 会通过队列队列：

![image](https://tva1.sinaimg.cn/large/008cOUgNgy1h55mk4gwylj30ly0b8t9z.jpg)

最后 React 会将 42 作为最终结果

### 回顾

批处理指的是 React 在事件处理函数执行完成后，再处理状态更新。即：React 会等到事件处理函数中的所有代码都运行后（会将更新动作放到状态队列中），才会处理状态更新（所以重渲染只发生在所有 `setState` 调用后）。在重渲染期间，React 将处理状态队列，状态更新函数（setState）就是在渲染期间执行。

在严格模式下，React 会执行每个更新函数两次（但是丢弃第二个结果），以帮助开发者发现错误。
