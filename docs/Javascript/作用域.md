---
sidebar_position: 3
---

# 作用域

所谓**作用域就是变量可以被访问到的范围。**

`ES6`之前函数只有全局作用域和函数作用域（或者叫局部作用域），`ES6`之后，多了块级作用域。

## 全局作用域

在代码中任何地方都能被访问到。

- `window`对象的属性
  
- 最外层函数、最外层函数外面定义的变量
  
- 所有末定义直接赋值的变量自动声明为拥有全局作用域
  

```js
var outVariable = "外层变量"
function outFun2() {
    var inVariable = "内层变量";
    globalVariable = "全局变量"
    console.log(outVariable) // "外层变量"
}

// 这是最外层函数，可以在任何地方都被调用
outFun2();
console.log(globalVariable) // "全局变量"
console.log(inVariable); // Uncaught ReferenceError: inVariable is not defined
```

## 函数作用域

是指声明在函数内部的变量，只能在函数内被访问到。

**作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行**

> 作用域链是在定义的时候创建的，就是写代码的那一刻就被确定了

```js
function doSomething(){
    var blogName="blog";
    function innerSay(){
        var blog="123"
        console.log(blog,blogName) // "123" "blog"
    }
    console.log("blog:",blog) // Uncaught ReferenceError: blog is not defined at doSomething
    innerSay(); 
}
doSomething()
console.log(blogName); // Uncaught ReferenceError: blogName is not defined
innerSay(); // Uncaught ReferenceError: innerSay is not defined
```

```js
var name = "789"
function foo(){
    var name = "123"
    console.log(name) 
    var name = "456"
}
var name = "101010"


foo() // "123"
```

## 块级作用域

> `JS` 的初学者经常需要花点时间才能习惯变量提升，而如果不理解这种特有行为，就可能导致 `bug` 。正因为如此， `ES6` 引入了块级作用域，让变量的生命周期更加可控。

块级作用域可通过新增命令`let`和`const`声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：

1. 在一个函数内部
2. 在一个代码块（由一对花括号包裹）内部

`let` 声明的语法与 `var` 的语法一致。你基本上可以用 `let` 来代替 `var` 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：

- 没有变量提升
  
- 在同一个块内，禁止重复声明
  
- 在`const`声明的时候一定要初始化，`let`可以只声明
  
- `let`、`const`存在暂时性死区
  
- 循环中的绑定块作用域