---
sidebar_position: 3
---

我们在学到数据类型的时候就知道，基础数据类型分配在栈上（变量名、变量值），引用数据类型分配在堆上（变量名、变量值存的时堆上的引用地址）。

## 栈

栈结构是程序运行的基础，因为每当函数被调用，一块连续的内存就会在栈顶被分配出来，这块内存被称为帧（frame）；

第一次载入`JS`代码，首先会创建一个全局环境（就是`main`函数对应的帧），直到程序退出才会被销毁（比如关闭浏览器）；随着函数一层层被调用，栈会一层层扩展；调用结束，栈又会一层层回溯，把内存释放回去。

一旦当前程序的调用栈超出了系统允许的最大栈空间，无法创建新的帧，来运行下一个要执行的函数，就会发生栈溢出，这时程序会被系统终止，产生崩溃信息。最常见的是递归函数没有设置边界，最后溢出，这时程序会被系统终止，产生崩溃信息。

只需要移动栈指针（stack pointer），虽然函数对应的执行上下文虽然保存在栈内存中，但是已经是无效内存了，再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。

## 堆

`JavaScript`是使用垃圾回收的语言，也就是执行环境负责在代码执行时管理内存。重点在于标记不再被使用的变量：

- 标记清除
  
- 引用计数
  

先说一下引用计数。

### 引用计数

**记录每个值被引用的次数。**

声明变量并且赋一个引用值时，这个值的引用数为`1`；如果同一个值又赋给另一个变量，那么引用数会增加`1`，如果这个变量被其他值覆盖，那么引用数减`1`。当一个值的引用数为零，就意味着不会再被访问到，所以可以安全释放对应的内存空间。

引用计数的问题在于可能会有循环引用：

> 对象A的一个指针指向`B`，对象`B`也引用了`A`对象。

```js
function badCycle() {
  var cycleObj1 = {}
  var cycleObj2 = {}
  cycleObj1.target = cycleObj2
  cycleObj2.target = cycleObj1
}

badCycle()
```

如果是引用计数，对于`cycleObj1`和`cycleObj2`，这两个对象的引用数都是`1`，所以不会被释放；不过对于标记清除来讲，当`badCycle()`执行完，`cycleObj1`和`cycleObj2`不会在上下文中再出现，所以对应的内存也会被释放。

### 标记清除

新生代和老生代是两个方案：

- 新生代：存活对象（被引用的对象）从`from`空间复制到`to`空间，当复制完成后，`from` 空间和 `to` 空间进行调换，`to` 空间会变为新的 from 空间，原来的 `from` 空间则变为 `to` 空间。再有新的对象，就会继续这样操作，新的对象放到`from`区域，再垃圾回收。
  
- 老生代：**标记清除方案。** 标记阶段会从`window`出发遍历堆中所有对象，并对**可以访问到的对象进行标记**；清除阶段则是对未标记对象的空间进行回收。