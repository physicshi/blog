---
sidebar_position: 7
---

![](http://tva1.sinaimg.cn/large/006T9etDly1gywlwxcrh2j30z60l4gv2.jpg)
![](http://tva1.sinaimg.cn/large/006T9etDly1gywlxdtj2gj30zm07ygpd.jpg)

首先应该明确的是，浏览器发送一个 http 请求有很多种方式（如上图），我们可以通过`type`字段区分不同方式发送的 HTTP 请求，比如请求一个 html 页面资源的类型为 document，使用 `<script>` 请求一个 js 脚本资源的类型是 script ，使用 XMLHttpRequest 请求一个接口的类型为 xhr。

我们今天讨论的就是 xhr ，它是唯一能触发浏览器跨域策略的请求类型。

> 实际上，同源策略还会限制：
>
> - Cookie、localStorage、IndexedDB 等存储性内容无法读取
> - DOM 节点无法获取
> - AJAX 请求发送后，结果会被浏览器拦截
>
>   但是有三个标签是允许跨域加载资源：
>
> - `<img src=XXX>`
> - `<link href=XXX>`
> - `<script src=XXX>`
>
>   表单提交、链接这些项等同于切换页面，script 标签的 src、link 标签的 href、img 标签的 src、iframe 标签的 src，上述的资源可以引用，但是不可获取内容。img 可以显示出来，但是你无法放入 canvas 二次使用，会把 canvas 的源污染。
>   iframe 可以显示，不可以获取 DOM；
>   script 不可获取报错代码位置。

一个 xhr 请求包含请求行、消息报头(Header)、请求正文(Body)三个部分。其中请求行中包含了本次请求的 URL，是否跨域主要是根据请求 URL 与当前发送请求的 html 页面地址是否是同源来决定。

当一个 URL 的协议、域名、端口号全部一致则为同源。

![](http://tva1.sinaimg.cn/large/006T9etDly1gyx7c7tj31j314m09eq9v.jpg)

当协议、域名、端口号中任意一个不相同时，都算作不同域。不同域之间的 xhr，就算作“跨域”。

> 浏览器的同源策略，出于安全的考量（如果缺少了同源策略，浏览器很容易受到 XSS、CSRF 等攻击），跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。

比如我们在页面`http://127.0.0.1:5500/index.html` 使用 xhr 请求接口 `http://localhost:3000/api/alloworigin` 时，则浏览器抛出跨域错误：

![](http://tva1.sinaimg.cn/large/006T9etDgy1gyxbh0glmfj30zo0a2qh1.jpg)

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script src="https://lib.baomitu.com/axios/0.21.1/axios.js"></script>
    <script>
      const Axios = axios;
      (async () => {
        const axios = Axios.create({
          baseURL: "http://localhost:3000",
        });
        const res = await axios.get("/api/alloworigin");
      })();
    </script>
  </body>
</html>
```

```js
const Koa = require("koa");

const app = new Koa();

const port = "5500";
const host = "localhost";

app.use(async (ctx) => {
  const { path } = ctx;
  if (path === "/api/alloworigin") {
    console.log("path:", path);
    ctx.body = "a";
  } else {
    ctx.body = "hello world";
  }
});

app.listen(port, host, () => {
  console.log(`API server listening on ${host}:${port}`);
});
```

## JSONP

JSONP 的全部内容就是利用了 script 标签没有跨域限制。

**不过 JSONP 有一个问题就是，仅支持 get 方法**。

### 流程解析

1. 前端定义解析函数（例如 jsonpCallback=function(){....}）
2. 通过 params 形式包装请求参数，并且声明执行函数(例如 cb=jsonpCallback)
3. 后端获取前端声明的执行函数（jsonpCallback），并以带上参数并调用执行函数的方式传递给前端

### 代码

node 服务：

```js
const Koa = require("koa");
const fs = require("fs");
const app = new Koa();
app.use(async (ctx, next) => {
  if (ctx.path === "/api/jsonp") {
    const { cb, msg } = ctx.query;
    ctx.body = `${cb}(${JSON.stringify({ msg })})`;
    return;
  }
});
app.listen(8080);
```

前端：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script type="text/javascript">
      window.jsonpCallback = function (res) {
        console.log(res);
      };
    </script>
    <script
      src="http://localhost:8080/api/jsonp?msg=hello&cb=jsonpCallback"
      type="text/javascript"
    ></script>
  </body>
</html>
```

![](http://tva1.sinaimg.cn/large/006T9etDly1gyzb7x4g4aj3150074tem.jpg)

### 原理解析

首先来看最简单的 js 调用：

```html
<!-- 首先声明了 jsonpCallback 函数-->
<script>
  window.jsonpCallback = function (res) {
    console.log(res);
  };
</script>
<!-- 然后调用 -->
<script>
  jsonpCallback({ a: 1 });
</script>
```

外链的形式：

```html
<script>
  window.jsonpCallback = function (res) {
    console.log(res);
  };
</script>
<script src="http://localhost:8080/api/a.js"></script>

<!--  http://localhost:8080/api/a.js 的内容是 jsonpCallback({a:1}); -->
```

现在只不过这个外链是一个动态的接口，后端返回了**带上参数的执行函数**：

```html
<script>
  window.jsonpCallback = function (res) {
    console.log(res);
  };
</script>
<script src="http://localhost:8080/api/a.js?a=123&cb=jsonpCallback"></script>
<!--  http://localhost:8080/api/a.js?a=123&cb=jsonpCallback 返回的内容是 cb(JSON.stringify(a)) => jsonpCallback({a:123}); -->
```

### 封装 JSONP

```js
function jsonp({ url, params, callback }) {
  return new Promise((resolve, reject) => {
    let script = document.createElement("script");
    window[callback] = function (data) {
      resolve(data);
      document.body.removeChild(script);
    };
    params = { ...params, callback }; // wd=b&callback=show
    let arrs = [];
    for (let key in params) {
      arrs.push(`${key}=${params[key]}`);
    }
    script.src = `${url}?${arrs.join("&")}`;
    document.body.appendChild(script);
  });
}
jsonp({
  url: "http://localhost:3000/say",
  params: { wd: "Iloveyou" },
  callback: "show",
}).then((data) => {
  console.log(data);
});
```

上面这段代码相当于向 `http://localhost:3000/say?wd=Iloveyou&callback=show` 这个地址请求数据，然后后台返回 `show('我不爱你')`，最后会运行 show()这个函数，打印出'我不爱你'

node 服务：

```js
let express = require("express");
let app = express();
app.get("/say", function (req, res) {
  let { wd, callback } = req.query;
  console.log(wd); // Iloveyou
  console.log(callback); // show
  res.end(`${callback}('我不爱你')`);
});
app.listen(3000);
```

## CORS 跨域资源共享

CORS 英文全称 Cross-origin resource sharing，中文翻译为跨域资源共享，是 W3C 标准，也是目前最推荐的跨域解决方案，该解决方案主要包含以下三种情况：

### 简单跨域请求

在 cors 里，请求被分为两种类型，一种是简单跨域请求，另一种则是复杂跨域请求，**浏览器会判断跨域请求是否为简单请求**。

简单请求会对请求方式、请求头字段、Content-Type 的值作出限制：

1. 为 GET、POST、HEAD 之一
2. 没有人为设置以下集合之外的其他请求头字段

- Accept
- Accept-Language
- Content-Language
- Content-Type

3. Content-Type 的值是否为下列三者之一

- text/plain
- multipart/form-data
- application/x-www-form-urlencoded

4. 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器。XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问
5. 请求中没有使用 ReadableStream 对象

前端代码：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>hello world</h1>
    <script src="https://lib.baomitu.com/axios/0.21.1/axios.js"></script>
    <script>
      /**
       * 简单跨域请求
       * 请求流程：浏览器发送简单跨域请求，服务端正常响应请求，浏览器接受请求时发现响应头中没有Access-Control-Allow-Origin，浏览器拒绝接受请求
       * 解决方法：服务端只需要加一个Access-Control-Allow-Origin就可以跨域访问
       */
      const Axios = axios;
      (async () => {
        const axios = Axios.create({
          baseURL: "http://127.0.0.1:3000",
        });
        const res = await axios.get("/api/alloworigin");
        console.log("res", res);
      })();
    </script>
  </body>
</html>
```

这条请求能够正确被服务端接收处理和返回，但浏览器收到结果时会去响应头中判断 Access-Control-Allow-Origin 字段，不符合则拒绝接收该请求并抛出跨域错误。

解决这个错误只需要服务端在响应头中添加 Access-Control-Allow-Origin 便可解决。

![](http://tva1.sinaimg.cn/large/006T9etDly1gyyf2nmcjmj30zy15y7wh.jpg)

```js
const Koa = require("koa");

const app = new Koa();

const port = "3000";
const host = "127.0.0.1";

app.use(async (ctx) => {
  const { path } = ctx;
  if (path === "/api/alloworigin") {
    console.log("path:", path);
    ctx.body = "a";
    // 设置header
    ctx.set("Access-Control-Allow-Origin", "http://localhost:5500");
  } else {
    ctx.body = "hello world";
  }
});

app.listen(port, host, () => {
  console.log(`API server listening on ${host}:${port}`);
});
```

### 复杂跨域请求

不符合以上条件的请求就是复杂请求了。

当浏览器判断当前请求为复杂跨域请求时，浏览器会提高安全等级，先发送一个 OPTIONS 类型的预检请求，如果 OPTIONS 请求正确返回（这是后端设置的，允许哪些请求头，允许哪些请求方法等）并且符合复杂跨域标准，才会发送真正的跨域请求去请求数据。如果 OPTIONS 请求没返回或不符合复杂跨域标准，则预检请求失败，接口请求失败。

**OPTION 请求可以理解为向服务器请求权限信息**，server 端检查通过则允许传输数据，检查不通过则不再发送真正想要发送的消息。因为复杂请求可能会加一些自定义的请求头之类的，要看服务端那边是否支持真实请求进行跨域资源访问。

解决这个错误需要先在服务端处理 OPTIONS 类型的请求，然后返回符合复杂跨域标准的响应头。

> 真实请求的信息在 OPTIONS 请求中通过 Access-Control-Request-Method Header 和 Access-Control-Request-Headers Header 描述。

> 注：带预检 (Preflighted) 的跨域请求的第一次请求，header 中不会带自定义的 header 头信息。表示真实请求的自定义 Header 列表的是 Access-Control-Request-HeadersHTTP 请求头。

![](http://tva1.sinaimg.cn/large/006T9etDly1gyyg3juuhcj30zu0ug15e.jpg)

![](http://tva1.sinaimg.cn/large/006T9etDly1gyyg56psy1j30z415gdw3.jpg)

![](http://tva1.sinaimg.cn/large/006T9etDly1gyyg5t67vsj30z80ty4lh.jpg)

前端代码：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>hello world</h1>
    <script src="https://lib.baomitu.com/axios/0.21.1/axios.js"></script>
    <script>
      const Axios = axios;
      (async () => {
        /**
         * 复杂跨域请求
         * 请求流程：浏览器发送复杂跨域请求时会提高安全等级，先发送一个OPTION类型的预检请求，请求没任何返回，预检请求失败，接口请求失败
         * 解决方法：服务端处理OPTIONS请求并返回正确的响应头，浏览器校验响应头发现符合复杂跨域标准，预检请求成功，后续和简单跨域请求流程一致
         */
        const axios = Axios.create({ baseURL: "http://127.0.0.1:3000" });
        const res = await axios.get("/api/alloworigin", {
          headers: { "Test-Token": "123" },
        });
        console.log("复杂跨域请求: ", res);
      })();
    </script>
  </body>
</html>
```

服务端代码：

```js
const Koa = require("koa");

const app = new Koa();

const port = "3000";
const host = "127.0.0.1";

app.use(async (ctx) => {
  const { path } = ctx;
  if (path === "/api/alloworigin" && ctx.method === "OPTIONS") {
    console.log("path:", path);
    ctx.body = "a";
    // 可以通过预检请求的域名
    ctx.set("Access-Control-Allow-Origin", "http://localhost:5500");
    // 可以通过预检请求的headers
    ctx.set("Access-Control-Allow-Headers", "Test-Token");
    // 可以通过预检请求的method
    ctx.set("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE");
  } else if (path === "/api/alloworigin" && ctx.method === "GET") {
    ctx.body = "hello world";
    ctx.set("Content-Type", "application/json");
    ctx.set("Access-Control-Allow-Origin", "http://localhost:5500");
    ctx.set("Set-Cookie", "test=123");
  }
});

app.listen(port, host, () => {
  console.log(`API server listening on ${host}:${port}`);
});
```

### 跨域请求携带 Cookie

跨域请求默认不携带 cookie，但有时在做业务开发时服务端还是需要根据 cookie 来做一些逻辑判断。

CORS 也提供了携带 Cookie 的功能，主要有两步，1.客户端发送请求时指定 withCredentials 为 true，2.服务端在响应头设置 Access-Control-Allow-Credentials 为 true。

> Access-Control-Allow-Origin 为非 \*

浏览器将携带 Cookie Header 的请求发送到服务器端后，如果服务器没有响应 Access-Control-Allow-Credentials Header，那么浏览器会忽略掉这次响应。

前端代码：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>hello world</h1>
    <script src="https://lib.baomitu.com/axios/0.21.1/axios.js"></script>
    <script>
      const Axios = axios;
      document.cookie = "name = 111";
      (async () => {
        /**
         * 跨域请求携带Cookie
         * 请求流程：浏览器发送跨域请求时默认不会携带cookie，服务端无法接受到cookie导致服务端异常
         * 解决方法：浏览器请求时添加withCredentials，此时服务端能接收到cookie，
         * 但返回响应时需要在响应头中添加Access-Control-Allow-Credentials，
         * 浏览器判断响应头中是否有Access-Control-Allow-Credentials，如果有则接受请求
         */
        const axios = Axios.create({
          baseURL: "http://127.0.0.1:3000",
          withCredentials: true,
        });
        const res = await axios.get("/api/alloworigin");
        console.log("复杂跨域请求: ", res);
      })();
    </script>
  </body>
</html>
```

服务端代码：

```js
const Koa = require("koa");

const app = new Koa();

const port = "3000";
const host = "127.0.0.1";

app.use(async (ctx) => {
  const { path } = ctx;
  if (path === "/api/alloworigin") {
    // 跨域请求携带cookie
    ctx.set("Access-Control-Allow-Credentials", true);
    ctx.body = "hello world";
    ctx.set("Access-Control-Allow-Origin", "http://localhost:5500");
  } else {
    ctx.body = "hello";
  }
});

app.listen(port, host, () => {
  console.log(`API server listening on ${host}:${port}`);
});
```

## nginx 反向代理

解决前端本地开发环境调用线上接口时跨域的问题。

本质上就是将 Nginx 作为跳板，我们直接访问 nginx，nginx 配置 `proxy_pass http://127.0.0.1:3000; add_header Access-Control-Allow-Origin $http_origin;`，也就是说我们访问 `nginxip:port`（默认是 127.0.0.1:8000） 相当于访问 `http://127.0.0.1:3000`，并且 nginx 设置了
`add_header Access-Control-Allow-Origin $http_origin;`

该方法本质上就是设置了 nginx 服务器允许的哪些源，$http_origin 是 nginx 的变量，表示用户的源。Nginx server 和 api server 是没有跨域的概念的，Nginx 服务器作为反向代理，将请求转发给 api server，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。

![](http://tva1.sinaimg.cn/large/006T9etDgy1gyye0pfu8dj30zg0iin4w.jpg)

配置前：

![image](https://tva4.sinaimg.cn/large/006T9etDly1h0akdvq22lj30wi0487ak.jpg)

配置后：

![image](https://tvax2.sinaimg.cn/large/006T9etDly1h0akh14ptij30xa08ydo2.jpg)

```
    listen 8000;
    server_name 127.0.0.1;
    location /api {
        proxy_pass http://127.0.0.1:3000;
        add_header Access-Control-Allow-Origin $http_origin;
    }
```

前端的代码

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>hello world</h1>
    <script src="https://lib.baomitu.com/axios/0.21.1/axios.js"></script>
    <script>
      const Axios = axios;
      (async () => {
        const axios = Axios.create({
          // 直接去访问 nginx 地址，默认是 8000
          baseURL: "http://127.0.0.1:8000",
        });
        const res = await axios.get("/api/alloworigin");
        console.log("res", res);
      })();
    </script>
  </body>
</html>
```

node 代码

```js
const Koa = require("koa");

const app = new Koa();

const port = "3000";
const host = "127.0.0.1";

app.use(async (ctx) => {
  const { path } = ctx;
  if (path === "/api/alloworigin") {
    console.log("path:", path);
    ctx.body = "a";
  } else {
    ctx.body = "hello world";
  }
});

app.listen(port, host, () => {
  console.log(`API server listening on ${host}:${port}`);
});
```

当然也可以有其他种设置：

```
    listen 8000;
    server_name 127.0.0.1;
    location / {
        proxy_pass http://127.0.0.1:5500;
    }
    location /api {
        proxy_pass http://127.0.0.1:3000;
    }
```

也就是说，访问 `127.0.0.1:8000` 其实就是访问 `127.0.0.1:5500`，访问 `127.0.0.1:8000/api` 就是访问 `127.0.0.1:3000/api`，这时候浏览器打开 `127.0.0.1:8000` 就是我们的 `index.html`（相当于打开了 `127.0.0.1:5500`），请求的源 `127.0.0.1:8000` 请求地址 `127.0.0.1:8000/api`，所以不存在跨域。

![](http://tva1.sinaimg.cn/large/006T9etDly1gyyes7bku5j30zk0v4kfq.jpg)

（示例代码和上面那种 Nginx 配置时一致）
