<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.5">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="我的秘密基地 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="我的秘密基地 Blog Atom Feed"><title data-react-helmet="true">浏览器的架构 | 我的秘密基地</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://physicshi.github.io/docs/浏览器/浏览器的架构"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="浏览器的架构 | 我的秘密基地"><meta data-react-helmet="true" name="description" content="我们都知道 JavaScript 是单线程的，在某个时刻只有特定代码被执行，并阻塞其他代码。这意味着同步。"><meta data-react-helmet="true" property="og:description" content="我们都知道 JavaScript 是单线程的，在某个时刻只有特定代码被执行，并阻塞其他代码。这意味着同步。"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://physicshi.github.io/docs/浏览器/浏览器的架构"><link data-react-helmet="true" rel="alternate" href="https://physicshi.github.io/docs/浏览器/浏览器的架构" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://physicshi.github.io/docs/浏览器/浏览器的架构" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.28eae8ec.css">
<link rel="preload" href="/assets/js/runtime~main.37cdd0ce.js" as="script">
<link rel="preload" href="/assets/js/main.45a0d8d5.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_RZKW">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_RFGx themedImage--light_Ble8 navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_RFGx themedImage--dark_wwiP navbar__logo"><b class="navbar__title">秘密基地</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">笔记📒</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/physicshi" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_mu0C"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_nWAW react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_MFxJ">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_MFxJ">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_IIrL"><button class="clean-btn backToTopButton_x+Rm" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_psz0"><div class="sidebar_aYCW"><nav class="menu thin-scrollbar menu_h+Ol menuWithAnnouncementBar_GKH3"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/intro">写在前面</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">浏览器</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/浏览器/概览">概览</a></li><li class="menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/浏览器/浏览器的架构">浏览器的架构</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/浏览器/v8的工作流程">v8 的工作流程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/浏览器/v8的内存管理">v8的内存管理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/浏览器/性能检测">性能检测</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/浏览器/JS的执行">代码在 JS 中是如何被执行的呢？</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/浏览器/跨域">跨域</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/浏览器/事件循环">事件循环</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">CSS</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">JavaScript</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">TypeScript</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">webpack</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">React</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Vite</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">taro</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Babel</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">NodeJS</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">探索</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">leetcode</a></li></ul></nav></div></aside><main class="docMainContainer_jMVY"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_+GTl"><div class="docItemContainer_RH7h"><article><div class="tocCollapsible_y1bX tocMobile_zI+Y"><button type="button" class="clean-btn tocCollapsibleButton_U+cm">On this page</button></div><div class="markdown"><header><h1>浏览器的架构</h1></header><p>我们都知道 JavaScript 是单线程的，在某个时刻只有特定代码被执行，并阻塞其他代码。这意味着同步。</p><blockquote><p>设计为单线程主要是对页面交互的同步处理。JS 的主要用途是与用户互动和操作 DOM，如果是多个线程会存在很严重的同步问题。</p></blockquote><p>不过我们还听过异步这个词。当然，单线程和异步确实不能同时成为一个语言的特性。js 选择了成为单线程的语言，所以它本身不可能是异步的，但 js 的宿主环境（比如浏览器，Node）是多线程的，宿主环境通过某种方式（事件循环）使得 js 具备了异步的属性。</p><p><strong>所谓异步，也只是用同步去模拟。</strong></p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_jJj8" id="常见的浏览器内核"></a>常见的浏览器内核<a class="hash-link" href="#常见的浏览器内核" title="Direct link to heading">#</a></h2><table><thead><tr><th>浏览器/runtime</th><th>内核(渲染引擎)</th><th>JavaScript 引擎</th></tr></thead><tbody><tr><td>Chrome</td><td>Blink(28~)<br>Webkit(chrome27)</td><td>V8</td></tr><tr><td>FireFox</td><td>Gecko</td><td>SpiderMonkey</td></tr><tr><td>Safari</td><td>Webkit</td><td>JavaScriptCore</td></tr><tr><td>Edge</td><td>Blink</td><td>Chakra</td></tr><tr><td>IE</td><td>Trident(IE4~IE11)</td><td>Chakra</td></tr><tr><td>Node.js</td><td>-</td><td>V8</td></tr></tbody></table><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_jJj8" id="浏览器架构"></a>浏览器架构<a class="hash-link" href="#浏览器架构" title="Direct link to heading">#</a></h2><p>最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork Service）进程、多个渲染进程和多个插件进程。</p><blockquote><p>打开 1 个页面至少需要 1 个浏览器主进程、1 个 GPU 进程、1 个网络进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="浏览器进程"></a>浏览器进程<a class="hash-link" href="#浏览器进程" title="Direct link to heading">#</a></h3><p>浏览器的主进程负责界⾯显示（地址栏、导航栏、书签等）、处理用户事件、管理子进程等。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="渲染进程"></a>渲染进程<a class="hash-link" href="#渲染进程" title="Direct link to heading">#</a></h3><p>浏览器会为每个标签页单独启动一个渲染进程，所以它和上述进程不同，并不是唯一的。</p><blockquote><p>出于安全考虑，渲染进程都是运行在沙箱模式下（通过操作系统的权限机制）。<br>
因为我们在渲染进程里的一切都是在网络上拿到的，可能会有一些恶意代码利用浏览器漏洞对系统进行攻击。</p></blockquote><p>渲染进程的任务是将 HTML、CSS 和 JavaScript 转化为⽤户可以与之交互的网页，<strong>每个渲染进程都会启动单独的渲染引擎线程和 JavaScript 引擎（V8）线程。</strong></p><p>除此之外还包括事件触发线程，负责接收事件，并将回调函数放入 JavaScript 引擎线程的事件队列中，以及负责处理定时任务的定时器线程。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_jJj8" id="每个标签页单独启动一个渲染进程"></a>每个标签页单独启动一个渲染进程<a class="hash-link" href="#每个标签页单独启动一个渲染进程" title="Direct link to heading">#</a></h4><ul><li>保障了安全性（为每个渲染进程建立一个沙箱运行环境）</li><li>保障了稳定性（某个标签页失去响应，用户可以关掉这个标签页，此时其他标签页依然运行着，可以正常使用）</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="gpu-进程"></a>GPU 进程<a class="hash-link" href="#gpu-进程" title="Direct link to heading">#</a></h3><p>处理来自其他进程的 GPU 任务，比如来自渲染进程或插件进程的 CSS3 动画效果，来自浏览器进程的界面绘制等。</p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</h5></div><div class="admonition-content"><p>其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p><p>浏览器渲染页面的过程，有一个步骤是“绘制”，我们提到了图层的合成，而这个图层的合成操作其实就是交给 GPU 进程来完成的。</p><p>它还有一个重要的特性，那就是可以利用 GPU 硬件来加速渲染，包括 Canvas 绘制、CSS3 转换（Transitions）、CSS3 变换（Transforms）、WebGL 等。具体原理就是如果 DOM 元素使用了这些属性，GPU 进程就会在合成层的时候对它进行单独处理，提升到一个独立的层进行绘制，这样就能避免重新布局和重新绘制。</p></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="网络进程"></a>网络进程<a class="hash-link" href="#网络进程" title="Direct link to heading">#</a></h3><p>负责⻚⾯的⽹络资源加载，比如在地址栏输入一个网页地址，网络进程会将请求后得到的资源交给渲染进程处理。本来只是浏览器主进程的一个模块，现在为了将浏览器进程进行“服务化”，被抽取出来，成了一个单独的进程。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="插件进程"></a>插件进程<a class="hash-link" href="#插件进程" title="Direct link to heading">#</a></h3><p>主要是负责插件的运⾏，和渲染进程一样，也不是唯一的，浏览器会为每个插件都启动一个进程。</p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</h5></div><div class="admonition-content"><p>这样的设计也是从安全性和稳定性考虑。
因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</p></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_jJj8" id="从输入-url到页面展示"></a>从输入 URL，到页面展示<a class="hash-link" href="#从输入-url到页面展示" title="Direct link to heading">#</a></h2><p>这是一个很经典的问题。</p><blockquote><p>从整体上看，一共要经历 7 个阶段：</p><ol><li>输入 URL</li><li>DNS 解析 URL</li><li>建立 TCP 连接（连接复用）</li><li>发送 HTTP 请求</li><li>服务器收到请求，发送 HTTP 响应</li><li>浏览器解析渲染页面</li><li>关闭 TCP 连接</li></ol></blockquote><p>从浏览器进程的角度，主要有三个进程配合完成：</p><ol><li>浏览器进程</li><li>网络进程</li><li>渲染进程</li></ol><p><img alt="浏览器进程" src="/assets/images/chromeprocess-7927d33366e0a97b91ceb557507ba917.png"></p><p>可以看到，渲染进程是跑在安全沙箱里，这是因为我们在渲染进程里的一切都是在网络上拿到的，可能会有一些恶意代码利用浏览器漏洞对系统进行攻击。</p><p><strong>同样会经历 7 个阶段</strong></p><blockquote><p>前期是浏览器进程和网络进程的通信，后期是浏览器进程、渲染进程、网络进程之间的通信</p></blockquote><ol><li>首先，浏览器进程接收到用户输入的 url 请求，浏览器进程便将该 URL 转发给网络进程。</li></ol><blockquote><p>浏览器进程通过进程间通信（IPC）将 URL 发送至<strong>网络进程</strong></p></blockquote><ol start="2"><li><p>在网络进程发起真正的 URL 请求。</p></li><li><p>接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。</p></li><li><p>浏览器进程接收到网络进程的响应头数据之后，便调用&quot;<code>CommitNavigation</code>&quot;函数发送 IPC 消息到渲染进程。</p></li></ol><blockquote><p>最终调用到<code>RenderFrameHostImpl::CommitNavigation()</code>，<code>RenderFrameHostImpl</code>发送了一个 IPC 消息到 Render 进程。</p><p><code>CommitNavigation()</code>函数会携带<code>response_header</code>、<code>request_params</code>等基本信息传递给渲染进程。</p></blockquote><ol start="5"><li><p>渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；</p></li><li><p>最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。</p></li></ol><blockquote><p>默认情况下，Chrome 会为每个页面分配一个渲染进程</p><p>如为同一站点（same-site），即根域名及协议一致，则会复用同一渲染进程</p></blockquote><ol start="7"><li>浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。</li></ol><blockquote><p>因为这里渲染进程和网络进程存在数据传输的阶段，文档数据传输完毕，浏览器进程才会收到渲染进程的消息，才会更新界面状态。所以输入 URL 后前一个页面还会存在一段时间。</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_jJj8" id="浏览器的渲染机制"></a>浏览器的渲染机制<a class="hash-link" href="#浏览器的渲染机制" title="Direct link to heading">#</a></h2><blockquote><p>渲染阶段可分为<strong>7 个子阶段</strong>：构建 DOM 树（html parser 解析 html 文件生成 DOM 树）、样式计算（解析 css 构建 cssom 树）、布局阶段（DOM 和 CSSOM 结合，生成可见布局树）、分层（根据层叠上下文创建图层）、绘制（对每个图层进行绘制）、分块（优先生成视口附近的位图/像素图）、栅格化和合成（栅格化就是指图块生成位图、合成就是栅格化后生成绘制命令，提交给浏览器进程）</p></blockquote><p>每个阶段关注三个部分：输入，处理过程，输出</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="1构建-dom-树"></a>1.构建 DOM 树<a class="hash-link" href="#1构建-dom-树" title="Direct link to heading">#</a></h3><p>HTML 文件经 HTML 解析器解析，生成 DOM 树</p><p>HTML 解析器并不是等整个文档加载完成之后再解析的，而是<strong>网络进程加载了多少数据，HTML 解析器便解析多少数据</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="2样式计算"></a>2.样式计算<a class="hash-link" href="#2样式计算" title="Direct link to heading">#</a></h3><p>解析 CSS，构建 CSSOM 树：标准化 style 值、结合继承规则计算 DOM 树每个节点的样式属性，保存在 ComputedStyle 中</p><p><strong>CSSOM 体现在 DOM 中就是 document.styleSheets</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="3布局阶段"></a>3.布局阶段<a class="hash-link" href="#3布局阶段" title="Direct link to heading">#</a></h3><blockquote><p><strong>从布局开始可能会有重排</strong></p></blockquote><p>DOM 和 CSSOM 结合，计算出 DOM 树中可见元素的几何位置</p><blockquote><p>visibility: hidden 这种也会绘制</p></blockquote><p>因为 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了<code>display:none</code>属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。<strong>DOM 树中所有不可见的节点都不包含到布局树中</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="4分层"></a>4.分层<a class="hash-link" href="#4分层" title="Direct link to heading">#</a></h3><p>根据层叠上下文属性对布局树进行分层，构建图层树</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="5绘制"></a>5.绘制<a class="hash-link" href="#5绘制" title="Direct link to heading">#</a></h3><p><strong>从绘制开始可能存在重绘</strong></p><p>根据图层树，依次对每个图层进行绘制</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="6分块"></a>6.分块<a class="hash-link" href="#6分块" title="Direct link to heading">#</a></h3><p>为防止开销过大，合成线程会将图层划分为图块，照视口附近的图块来优先生成位图</p><blockquote><p>图块生成位图具体是在栅格化阶段做的</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="7栅格化和合成"></a>7.栅格化和合成<a class="hash-link" href="#7栅格化和合成" title="Direct link to heading">#</a></h3><p><strong>图块是栅格化执行的最小单位</strong></p><p>栅格化指将图块转换为位图，一旦所有图块都被栅格化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p><p><strong>合成就是栅格化后生成绘制命令，提交给浏览器进程</strong></p><p>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_jJj8" id="重排和重绘"></a>重排和重绘<a class="hash-link" href="#重排和重绘" title="Direct link to heading">#</a></h2><p>重排和重绘就是样式计算阶段发生了改变，然后影响了布局或者绘制之后的整个流程更新。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="重排"></a>重排<a class="hash-link" href="#重排" title="Direct link to heading">#</a></h3><ul><li>更新元素的几何属性（宽，高等）</li><li>触发重新布局，开销最大</li></ul><p>触发重排的操作有：</p><ul><li>添加或删除可见的 DOM 元素 =&gt; 循环添加多个元素时，可借助 <code>DocumentFragment</code></li><li>元素位置改变</li><li>元素尺寸改变</li><li>内容改变</li><li>浏览器窗口尺寸改变</li><li><strong>获取需要及时计算的特定值</strong>，如 <code>offsetTop</code>、<code>offsetLeft</code>、 <code>offsetWidth</code>、<code>offsetHeight</code>，<code>getComputedStyle</code></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="重绘"></a>重绘<a class="hash-link" href="#重绘" title="Direct link to heading">#</a></h3><ul><li>更新元素绘制属性（如颜色）</li><li>直接进入绘制，省去布局和分层，执行效率比重排高</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="触发重排和重绘的操作"></a>触发重排和重绘的操作<a class="hash-link" href="#触发重排和重绘的操作" title="Direct link to heading">#</a></h3><p>重排肯定会带来重绘，但是重绘不会造成重排。</p><ul><li>添加、删除、更新 DOM 节点——重新生成布局树，所以会有重排和重绘</li><li>通过<code>display: none</code>（脱离文档）隐藏⼀个 DOM 节点——触发重排和重绘</li><li>通过<code>visibility: hidden</code>隐藏⼀个 DOM 节点——只触发重绘，因为没有⼏何变化</li><li>用户行为，例如调整窗口大小，改变字号，或者滚动——触发重排和重绘</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="如何避免重排或者重绘"></a>如何避免重排或者重绘<a class="hash-link" href="#如何避免重排或者重绘" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_jJj8" id="集中改变样式"></a>集中改变样式<a class="hash-link" href="#集中改变样式" title="Direct link to heading">#</a></h4><p>我们往往通过改变 class 的⽅式来集中改变样式</p><p>不要一条一条地修改 DOM 的样式。可以先定义好 css 的 class，然后修改 DOM 的 className。</p><div class="codeBlockContainer_JfZT"><div class="codeBlockContent_4mTi js"><pre tabindex="0" class="prism-code language-js codeBlock_P3uO thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_+v3f"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// 判断是否是⿊⾊系样式</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> theme </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> isDark </span><span class="token operator" style="color:#393A34">?</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;dark&quot;</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;light&quot;</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 根据判断来设置不同的class</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">ele</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">setAttribute</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;className&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> theme</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ww6L clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_jJj8" id="使用-documentfragment"></a>使用 documentFragment<a class="hash-link" href="#使用-documentfragment" title="Direct link to heading">#</a></h4><blockquote><p>我们可以通过 createDocumentFragment 创建⼀个游离于 DOM 树之外的节点，然后在此节点上批量操作，最后插⼊ DOM 树中，因此只触发⼀次重排</p></blockquote><p>避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中。</p><div class="codeBlockContainer_JfZT"><div class="codeBlockContent_4mTi js"><pre tabindex="0" class="prism-code language-js codeBlock_P3uO thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_+v3f"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">var</span><span class="token plain"> fragment </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token dom variable" style="color:#36acaa">document</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">createDocumentFragment</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword control-flow" style="color:#00009f">for</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">10</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i</span><span class="token operator" style="color:#393A34">++</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> node </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token dom variable" style="color:#36acaa">document</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">createElement</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;p&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  node</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">innerHTML</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> i</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  fragment</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">appendChild</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">node</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token dom variable" style="color:#36acaa">document</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">body</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">appendChild</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">fragment</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ww6L clean-btn">Copy</button></div></div><p>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_jJj8" id="浏览器加载顺序"></a>浏览器加载顺序<a class="hash-link" href="#浏览器加载顺序" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="阻塞的-script-标签"></a>阻塞的 script 标签<a class="hash-link" href="#阻塞的-script-标签" title="Direct link to heading">#</a></h3><p>正常的网页加载流程是这样的：</p><ol><li>浏览器一边下载 HTML 网页，一边开始解析</li><li>解析过程中，发现<code>&lt;script&gt;</code>标签</li><li>暂停解析，网页渲染的控制权转交给 JavaScript 引擎</li><li>如果<code>&lt;script&gt;</code>标签引用了外部脚本，就下载该脚本（暂停解析），否则就直接执行</li><li>执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页</li></ol><p>将 js 放在 body 的最后面，可以避免资源阻塞，同时使静态的 html 页面迅速显示。
如果外部脚本加载时间很长（比如一直无法完成下载），就会造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。
html 需要等 head 中所有的 js 和 css 加载完成后才会开始绘制，但是 html 不需要等待放在 body 最后的 js 下载执行就会开始绘制。</p><div class="admonition admonition-caution alert alert--warning"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>注意</h5></div><div class="admonition-content"><p>css 不会阻塞 html 解析，但是会阻塞渲染；<br>
js 既会阻塞 html 解析，也会阻塞渲染；</p></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="async-和-defer"></a>async 和 defer<a class="hash-link" href="#async-和-defer" title="Direct link to heading">#</a></h3><p>首先单独的 script 标签会阻塞浏览器解析<code>html</code>（可以理解为一个同步的过程，而且 script 之间顺序执行）</p><p><code>async</code>和<code>defer</code>这两个属性都不会阻塞解析<code>html</code>（异步加载），区别在于异步加载<code>script</code>的结果回来后，<code>async</code>属性的<code>script</code>标签会阻塞解析<code>html</code>，<code>defer</code>会等<code>html</code> 解析完毕再执行 <code>JS</code> 代码</p><p><strong><code>defer</code>延迟执行</strong>，等解析完<code>html</code>再执行</p><p>注意：async 的执行，并不会按着 script 在页面中的顺序来执行，而是谁先加载完谁执行。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_jJj8" id="场景"></a>场景<a class="hash-link" href="#场景" title="Direct link to heading">#</a></h4><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_jJj8" id="defer"></a>defer<a class="hash-link" href="#defer" title="Direct link to heading">#</a></h5><p>如果你的脚本代码依赖于页面中的 DOM 元素（文档是否解析完毕），或者被其他脚本文件依赖。
例：</p><ul><li>评论框</li><li>代码语法高亮</li><li>polyfill.js</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_jJj8" id="async"></a>async<a class="hash-link" href="#async" title="Direct link to heading">#</a></h5><p>如果你的脚本并不关心页面中的 DOM 元素（文档是否解析完毕），并且也不会产生其他脚本需要的数据。
例：</p><ul><li>百度统计</li></ul><blockquote><p>如果不太能确定的话，用 defer 总是会比 async 稳定</p></blockquote></div><footer class="docusaurus-mt-lg"><div class="row"><div class="col"><a href="https://github.com/facebook/docusaurus/edit/main/website/docs/浏览器/浏览器的架构.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_UQtd" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_QETb"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/浏览器/概览"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 概览</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/浏览器/v8的工作流程"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">v8 的工作流程 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_GySF thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#常见的浏览器内核" class="table-of-contents__link">常见的浏览器内核</a></li><li><a href="#浏览器架构" class="table-of-contents__link">浏览器架构</a><ul><li><a href="#浏览器进程" class="table-of-contents__link">浏览器进程</a></li><li><a href="#渲染进程" class="table-of-contents__link">渲染进程</a></li><li><a href="#gpu-进程" class="table-of-contents__link">GPU 进程</a></li><li><a href="#网络进程" class="table-of-contents__link">网络进程</a></li><li><a href="#插件进程" class="table-of-contents__link">插件进程</a></li></ul></li><li><a href="#从输入-url到页面展示" class="table-of-contents__link">从输入 URL，到页面展示</a></li><li><a href="#浏览器的渲染机制" class="table-of-contents__link">浏览器的渲染机制</a><ul><li><a href="#1构建-dom-树" class="table-of-contents__link">1.构建 DOM 树</a></li><li><a href="#2样式计算" class="table-of-contents__link">2.样式计算</a></li><li><a href="#3布局阶段" class="table-of-contents__link">3.布局阶段</a></li><li><a href="#4分层" class="table-of-contents__link">4.分层</a></li><li><a href="#5绘制" class="table-of-contents__link">5.绘制</a></li><li><a href="#6分块" class="table-of-contents__link">6.分块</a></li><li><a href="#7栅格化和合成" class="table-of-contents__link">7.栅格化和合成</a></li></ul></li><li><a href="#重排和重绘" class="table-of-contents__link">重排和重绘</a><ul><li><a href="#重排" class="table-of-contents__link">重排</a></li><li><a href="#重绘" class="table-of-contents__link">重绘</a></li><li><a href="#触发重排和重绘的操作" class="table-of-contents__link">触发重排和重绘的操作</a></li><li><a href="#如何避免重排或者重绘" class="table-of-contents__link">如何避免重排或者重绘</a></li></ul></li><li><a href="#浏览器加载顺序" class="table-of-contents__link">浏览器加载顺序</a><ul><li><a href="#阻塞的-script-标签" class="table-of-contents__link">阻塞的 script 标签</a></li><li><a href="#async-和-defer" class="table-of-contents__link">async 和 defer</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">笔记📒</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_mu0C"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_mu0C"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_mu0C"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/physicshi" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_mu0C"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 wsgy, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.37cdd0ce.js"></script>
<script src="/assets/js/main.45a0d8d5.js"></script>
</body>
</html>