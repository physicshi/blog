---
sidebar_position: 1
---

babel 最开始叫 6to5，是 es6 转 es5，从这个最初的名字也可以知道，babel 是一个 js 转译器。

babel 转译存在三个阶段：

![image](https://tvax4.sinaimg.cn/large/006T9etDly1h1vjgtakmcj31aq0i2gq7.jpg)

- parse：通过 parser 把源码转成抽象语法树（AST）
- transform：遍历 AST，调用各种 transform 插件对 AST 进行增删改
- generate：把转换后的 AST 打印成目标代码，并生成 sourcemap

## Babel 核心包

- @babel/core：负责转译的核心包，包含了整个 babel 的工作流（已集成 @babel/types）
- @babel/parser：负责解析源码，并生成 AST
- @babel/traverse：负责遍历 AST，并对 AST 进行增删改
- @babel/generator：负责生成目标代码
- @babel/types：包含手动构建 AST 以及检查 AST 节点类型的方法
- @babel/template：批量生成 AST 节点（可以将字符串代码片段转换为 AST 节点）

```shell
pnpm i @babel/core @babel/parser @babel/traverse @babel/generator @babel/types @babel/template -D
```

## Babel 的 AST

之所以叫抽象语法树 AST 是因为省略掉了源码中的分隔符、注释等内容，AST 也是有标准的，JS parser 的 AST 大多是 estree 标准，从 SpiderMonkey 的 AST 标准扩展而来。

我们可以通过 [AST Explorer](https://astexplorer.net/) 来查看 AST 的结构，可以看到，AST 是一个树状结构，每个节点都有一个 type 属性，表示节点的类型，比如：

```json
{
  "type": "Program",
  "start": 0,
  "end": 5,
  "body": [
    {
      "type": "ExpressionStatement",
      "start": 0,
      "end": 5,
      "expression": {
        "type": "Literal",
        "start": 0,
        "end": 5,
        "name": "hello"
      }
    }
  ]
}
```

AST 的类型：

| 类型        | 说明                                                                                        |
| ----------- | ------------------------------------------------------------------------------------------- |
| File        | 文件 (顶层节点包含 Program)                                                                 |
| Program     | 整个程序节点 (包含 body 属性代表程序体)                                                     |
| Directive   | 指令 (例如 "use strict")                                                                    |
| Comment     | 代码注释                                                                                    |
| Statement   | 语句 (可独立执行的语句)                                                                     |
| Literal     | 字面量 (基本数据类型、复杂数据类型等值类型)                                                 |
| Identifier  | 标识符 (变量名、属性名、函数名、参数名等)                                                   |
| Declaration | 声明 (变量声明、函数声明、Import、Export 声明等)                                            |
| Specifier   | 关键字 (ImportSpecifier、ImportDefaultSpecifier、ImportNamespaceSpecifier、ExportSpecifier) |
| Expression  | 表达式                                                                                      |

公共属性

| 类型             | 说明                                             |
| ---------------- | ------------------------------------------------ |
| type             | AST 节点的类型                                   |
| start            | 记录该节点代码字符串起始下标                     |
| end              | 记录该节点代码字符串结束下标                     |
| loc              | 内含 line、column 属性，分别记录开始结束的行列号 |
| leadingComments  | 开始的注释                                       |
| innerComments    | 中间的注释                                       |
| trailingComments | 结尾的注释                                       |
| extra            | 额外信息                                         |

## `@babel/parser`

对于`@babel/parser`：

```ts
function parse(input: string, options?: ParserOptions): File; // 这里返回的是整个 AST
```

这里的 `input` 是源码，`options` 是解析器的配置，默认是 `{}`。这里 parse 配置主要是：

- plugins： 指定 jsx、typescript、flow 等插件来解析对应的语法
- sourceType： 指定是否支持解析模块语法，有 module、script、unambiguous 3 个取值，module 是解析 es module 语法，script 则不解析 es module 语法，当作脚本执行，unambiguous 则是根据内容是否有 import 和 export 来确定是否解析 es module 语法。

```js
// parse tsx 模块
require("@babel/parser").parse("code", {
  sourceType: "module",
  plugins: ["jsx", "typescript"],
});
```

## `@babel/traverse` (核心)

Babel 插件本质上就是编写各种 visitor 去访问 AST 上的节点，并进行 traverse。当遇到对应类型的节点，visitor 就会做出相应的处理，从而将原本的代码 transform 成最终的代码。

> 编写一个 Babel 插件，要做的事情就是回传一个 visitor 对象，定义以 Node Type 为名称的函数。该函数接收 path,state 两个参数。

```js
function traverse(ast, opts) {}
```

- ast：经过 parse 之后的生成的 AST
- opts ：指定 visitor 函数--babel 会在遍历 AST 时调用相应的 visitor 函数

方法的第二参数中的 visitor 是我们自定义插件时经常用到的地方，你可以通过两种方式来定义这个参数：

1. 第一种是以方法的形式声明 visitor -- 相当于是 enter 时调用的函数

```js
traverse(ast, {
  BlockStatement(path, state) {
    console.log("BlockStatement>>>>>>");
  },
});
```

2. 第二种是以对象的形式声明 visitor -- 可以明确指定 enter 或者 exit 时的处理函数

```js
traverse(ast, {
  BlockStatement: {
    enter(path, state) {
      console.log("enter>>>", path, state);
    },
    exit(path, state) {
      console.log("exit>>>", path, state);
    },
  },
});
```

每一个 visitor 函数会接收两个参数 path 和 state，path 用来操作节点、遍历节点和判断节点，例如 path.node 可以访问当前节点，path.parent 可以访问父节点等。path.remove()可以移除当前节点。

![image](https://tva1.sinaimg.cn/large/006T9etDly1h1vkse3c7aj319e08o76z.jpg)

而 state 则是遍历过程中在不同节点之间传递数据的机制， 我们也可以通过 state 存储一些遍历过程中的共享数据。

## `@babel/types`

创建一些 AST 和判断 AST 的类型用到的，比如：

```js
import * as types from "@babel/types";

// 是否为标识符类型节点
if (types.isIdentifier(node)) {
  // ...
}

// 是否为数字字面量节点
if (types.isNumberLiteral(node)) {
  // ...
}

// 是否为表达式语句节点
if (types.isExpressionStatement(node)) {
  // ...
}
```

因为可以创建一些 AST 和判断 AST 的类型，**我们可以用@babel/types 包来写代码**（Babel Types 生成的 AST 节点需使用@babel/generator 转换后得到相应代码）：

```js
import * as types from "@babel/types";
import generator from "@babel/generator";
const generate = generator.default; // https://github.com/babel/babel/issues/13719

const log = (node) => {
  console.log(generate(node).code);
};

console.log(types.stringLiteral("Hello World")); // output: { type: 'StringLiteral', value: 'Hello World' }
// 这是最简单的生成一个字符串节点
log(types.stringLiteral("Hello World")); // output: "Hello World"

log(
  types.variableDeclaration("const", [
    types.variableDeclarator(types.identifier("a"), types.numericLiteral(1)),
  ])
); // output: const a = 1;
```

甚至可以通过 Babel Types 生成 react 代码。

## `@babel/generator`

转换完 AST 之后，就要打印目标代码字符串，这里通过@babel/generator 来实现：

```js
function generator(ast: Object, opts: Object, code: string): {code, map}
```

- 第一个参数是要打印的 AST
- 第二个参数是 options，指定打印的一些细节，比如通过 comments 指定是否包含注释，通过 minified 指定是否包含空白字符
- 第三个参数当多个文件合并打印的时候需要用到

options 中常用的是 sourceMaps，开启了这个选项才会生成 sourcemap

```js
const { code, map } = generate(ast, { sourceMaps: true });
```

## Babel 的内置功能

babel 的 plugin 是在配置文件里面通过 plugins 选项配置，值为字符串或者数组：

```json
{
  "plugins": [
    "pluginA",
    ["pluginB"],
    [
      "pluginC",
      {
        /* options */
      }
    ]
  ]
}
```

> 如果需要传参就用数组格式，第二个元素为参数。

前面我们介绍了几个用于实现插件的 api，而 babel 本身为了实现对语法特性的转换以及对 api 的支持(polyfill)，也内置了很多的插件(plugin)和预设(preset)。

其插件主要分为三类：

- syntax plugin：只是在 parse 阶段使用，可以让 parser 能够正确的解析对应的语法成 AST
- transform plugin：是对 AST 的转换，针对 es20xx 中的语言特性、typescript、jsx 等的转换都是在这部分实现的
- proposal plugin：未加入语言标准的特性的 AST 转换插件

而预设其实就是对于插件的一层封装，通过配置预设，使用者可以不用关心具体引用了什么插件，从而减轻使用者的负担。

根据上面不同类型的插件又产生了如下几种预设：

- 专门根据 es 标准处理语言特性的预设 -- babel-preset-es20xx
- 对 react、ts 兼容的预设 -- preset-react preset-typescript

babel plugin 有两种格式：

1. 返回对象的函数

第一种是一个函数返回一个对象的格式，对象里有 visitor、pre、post、inherits、manipulateOptions 等属性。

```js
export default function (api, options, dirname) {
  return {
    inherits: parentPlugin,
    manipulateOptions(options, parserOptions) {
      options.xxx = "";
    },
    pre(file) {
      this.cache = new Map();
    },
    // 插件的核心逻辑
    visitor: {
      StringLiteral(path, state) {
        this.cache.set(path.node.value, 1);
      },
    },
    post(file) {
      console.log(this.cache);
    },
  };
}
```

首先，插件函数有 3 个参数，api、options、dirname：

- options 就是外面传入的参数
- dirname 是目录名（不常用）
- api 里包含了各种 babel 的 api，比如 types、template 等，这些包就不用在插件里单独单独引入了，直接取来用就行。

返回的对象有 inherits、manipulateOptions、pre、visitor、post 等属性：

- inherits 指定继承某个插件，和当前插件的 options 合并，通过 Object.assign 的方式
- visitor 指定 traverse 时调用的函数
- pre 和 post 分别在遍历前后调用，可以做一些插件调用前后的逻辑，比如可以往 file（表示文件的对象，在插件里面通过 state.file 拿到）中放一些东西，在遍历的过程中取出来
- manipulateOptions 用于修改 options，是在插件里面修改配置的方式，比如 syntaxt plugin 一般都会修改 parser options

插件做的事情就是通过 api 拿到 types、template 等，通过 state.opts 拿到参数，然后通过 path 来修改 AST。可以通过 state 放一些遍历过程中共享的数据，通过 file 放一些整个插件都能访问到的一些数据，除了这两种之外，还可以通过 this 来传递本对象共享的数据

2. 对象

插件的第二种格式就是直接写一个对象，不用函数包裹，这种方式用于不需要处理参数的情况。

```js
export default plugin = {
  pre(state) {
    this.cache = new Map();
  },
  visitor: {
    StringLiteral(path, state) {
      this.cache.set(path.node.value, 1);
    },
  },
  post(state) {
    console.log(this.cache);
  },
};
```

- [import 方式随意互转，感受 babel 插件的威力](https://juejin.cn/post/7018563244679757855) 以及神光哥的小册

举例：

babel-plugin-transform-object-assign 源码

```js
import { declare } from "@babel/helper-plugin-utils";

export default declare((api) => {
  api.assertVersion(7);

  return {
    name: "transform-object-assign",

    visitor: {
      CallExpression: function (path, file) {
        if (path.get("callee").matchesPattern("Object.assign")) {
          path.node.callee = file.addHelper("extends");
        }
      },
    },
  };
});
```

上面的就是 babel-plugin-transform-object-assign 的源码。

- declare：是一个用于简化创建 transformer 的工具函数
- assertVersion：检查当前 babel 的大版本 -> 这里就通过 api 直接拿来用
- name：当前插件的名字
- visitor：对外提供修改内容的访问者
- CallExpression：函数调用的 type，每一句代码都会生成对应的 type，例如最上面的函数名 abc 则对应的是一个 Identifier 类型，如果需要修改某一个 type 的代码，则在里面创建对应的 type 访问者进行修改即可。

具体生成的代码如下：

```js
// input
const a = Object.assign({ a: 1 }, { b: 2 });

// output
function _extends() {
  _extends =
    Object.assign ||
    function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
  return _extends.apply(this, arguments);
}

const a = _extends(
  {
    a: 1,
  },
  {
    b: 2,
  }
);
```

## Babel 插件实战 - 清除 console 源码

```js
const babel = require("@babel/core");
const get = require("lodash/get");
const eq = require("lodash/eq");

const { transformAsync } = babel;

const removeConsole = {
  visitor: {
    ExpressionStatement: (path) => {
      const name = get(path, "node.expression.callee.object.name");
      const CONSOLE_PREFIX = "console";
      if (!eq(name, CONSOLE_PREFIX)) {
        return;
      }
      path.remove();
    },
  },
};

const transformCode = async (code = "") => {
  const res = await transformAsync(code, {
    plugins: [removeConsole],
  });

  console.log(res.code);
};

transformCode(`
    const a = 10;
    console.group('a');
    console.log(a);
    console.groupEnd();
`);
```

输出结果：

```js
const a = 10;
```

上面的功能就是我们在声明语句类型 ExpressionStatement 中实现的。

- node.expression 对应的是当前类型里的子表达式，在这个场景里，它的 type === 'CallExpression'
- callee 对应的就是一个调用函数类型，在这个场景里，它的 type === 'MemberExpression'
- object 对应的就是当前调用函数的前置对象，它的 type === 'Identifier'，name 则是 console

所以我们的实现就很简单了，只要 name === 'console' ，我们就可以通过内部暴露的 remove 方法直接删除当前代码。
