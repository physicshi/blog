---
sidebar_position: 1
---

React15 架构可以分为两层：

1. Reconciler（协调器）—— 负责找出变化的组件
2. Renderer（渲染器）—— 负责将变化的组件渲染到页面上

React16 架构可以分为三层：

1. Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入 Reconciler
2. Reconciler（协调器）—— 负责找出变化的组件
3. Renderer（渲染器）—— 负责将变化的组件渲染到页面上

vdom 架构（react 15）只有 render 和 reconciler：

diff 过程（patch 或者叫做 reconciler）是 vdom 和真实 dom 做的 diff，这是个递归的过程，没办法打断可能会卡顿。

fiber 架构（react 16）是 schedule，reconcile，render：

reconcile 过程首先是虚拟 dom 转 fiber，遍历 element 对象生成不同的 fiber 结点，然后比对 oldfiber 和新的 reactElement 结点，生成新的 fiber 结点，并且给这些新的 fiber 标记上 effecttag，这个过程可以打断（本质上是 fiber 链表结构配合 schedule，schedule 是 polyfill 的 requestidlecallback）。

> 更新从递归变成了可以中断的循环过程（以浏览器是否有剩余时间作为任务中断的标准）。每次循环都会调用 shouldYield（schedule 中导出的） 判断当前是否有剩余时间。

render 阶段（commit）是根据 effect tag 更新到 dom 的过程，这个过程不可以打断，一次性执行，否则会有 UI 更新不连续。整个 Scheduler 与 Reconciler 的工作都在内存中进行，只有当所有组件都完成 Reconciler 的工作，才会统一交给 Renderer。

[shouldYield](https://github.com/facebook/react/blob/v16.13.1/packages/react-reconciler/src/SchedulerWithReactIntegration.js)

:::tip
首先 React 向浏览器请求调度，浏览器在一帧中如果还有空闲时间，会去判断是否存在待执行任务，不存在就直接将控制权交给浏览器，如果存在就会执行对应的任务，执行完成后会判断是否还有时间，有时间且有待执行任务则会继续执行下一个任务，否则就会将控制权交给浏览器。

Fiber 可以被理解为划分一个个更小的执行单元，它是把一个大任务拆分为了很多个小块任务，一个小块任务的执行必须是一次完成的，不能出现暂停，但是一个小块任务执行完后可以移交控制权给浏览器去响应用户（浏览器去执行优先级更高的任务），从而不用像之前一样要等那个大任务（递归的调用栈很深）一直执行完成再去响应用户。

通过 Fiber 架构，让 reconcile 过程变得可被中断。适时地让出 CPU 执行权，可以让浏览器及时地响应用户的交互。
:::
