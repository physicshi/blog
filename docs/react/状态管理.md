---
sidebar_position: 4
---

我们说状态管理，本质上是在说**实现跨组件更新和数据管理的方式**。从这个定义来看，状态管理需要做到：状态变更后自动更新到该状态对应的组件。最理想的是做到更细粒度的更新，即只更新真正需要更新的 component。

## 为什么 React 需要状态管理？

> 根本原因在于 React 并不是完全的响应式的，状态怎么变更什么时候变更（useState 这些 hooks），react 把这些能力完全交给了开发者。所以会有各种状态管理的方案。

具体来讲：

![image](https://tva1.sinaimg.cn/large/006T9etDly1h1cswyv5pmj313e0f4gpb.jpg)

React 本身作为一个视图层的框架，核心理念是`UI=f(state)`，React 通过 setState 去改变数据，然后根据新的数据重新渲染出虚拟 DOM，最后通过对比虚拟 DOM 和 `current fiber` 找到需要更新的节点进行更新。

也就是说，如果你没有告诉 React 你的数据已经改变了（比如说调用 this.setState 或 Hooks 之类），那么虚拟 DOM 就不会有变化，React 也不会随之响应。**React 需要你手动跟踪应用数据，并在数据变化时告诉 React，这也意味着你得做更多工作**。

:::tip
整个过程本质上就是用 Scheduler 去调度任务的优先级，高优任务优先进入 Reconciler，然后 Reconciler 找出变化的组件，当 Scheduler 将任务交给 Reconciler 后，Reconciler 会为变化的虚拟 DOM 打上代表增/删/更新的标记

一个 DOM 节点在某一时刻最多会有 4 个节点和他相关：

- current Fiber。如果该 DOM 节点已在页面中，current Fiber 代表该 DOM 节点对应的 Fiber 节点
- workInProgress Fiber。如果该 DOM 节点将在本次更新中渲染到页面中，workInProgress Fiber 代表该 DOM 节点对应的 Fiber 节点
- DOM 节点本身
- JSX 对象。即 ClassComponent 的 render 方法的返回结果，或 FunctionComponent 的调用结果。JSX 对象中包含描述 DOM 节点的信息

Diff 算法的本质是对比 1 和 4，生成 2。
:::

## 状态管理方案

- 没有状态管理：直接用 props 或者 context
- 单项数据流：redux
- 双向绑定：mobx

### props/context

直接用 props ，React 原生只支持父子通信（父组件可以直接将 this.props 传入子组件）还有子父通信（父组件传递给子组件的是一个绑定了自身上下文的函数，那么子组件在调用该函数时，就可以将想要交给父组件的数据以函数入参的形式传给父级作用域），但是项目越大，会越来越麻烦。

对于 context，会存在一些性能问题，只要 context 的 value 发生变化，所有消费该 context 的组件都会 re-render。不过可以拆分 context+useMemo 来解决一些问题。

### redux

对于 redux，三大原则：1. 单一数据源、2. 纯函数 Reducer、3. State 是只读的，总的来说就是定义 action、reducer，通过 dispatch 来触发更新。

:::tip
纯函数是指：

- 相同输入总是会返回相同的输出
- 不产生副作用：副作用就是指外部交互，比如 ajax 请求
- 不依赖于外部状态

:::

### Mobx

对于 Mobx，Mobx 通过监听数据的属性变化，可以直接在数据上更改触发 UI 的渲染。

以 Mobx 5 为分界点，5 以前采用 Object.defineProperty 的方案，5 及以后使用 Proxy 的方案。最大的优点就是响应式自动更新数据。
