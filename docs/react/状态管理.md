---
sidebar_position: 4
---

我们说状态管理，本质上是在说**实现跨组件更新和数据管理的方式**。从这个定义来看，状态管理需要做到：状态变更后自动更新到该状态对应的组件。最理想的是做到更细粒度的更新，即只更新真正需要更新的 component。

## 为什么 React 需要状态管理？

> 根本原因在于 React 并不是完全的响应式的，状态怎么变更什么时候变更（useState 这些 hooks），react 把这些能力完全交给了开发者。所以会有各种状态管理的方案。

具体来讲：

![image](https://tva1.sinaimg.cn/large/006T9etDly1h1cswyv5pmj313e0f4gpb.jpg)

React 本身作为一个视图层的框架，核心理念是`UI=f(state)`，React 通过 setState 去改变数据，然后根据新的数据重新渲染出虚拟 DOM，最后通过对比虚拟 DOM 和 `current fiber` 找到需要更新的节点进行更新。

也就是说，如果你没有告诉 React 你的数据已经改变了（比如说调用 this.setState 或 Hooks 之类），那么虚拟 DOM 就不会有变化，React 也不会随之响应。**React 需要你手动跟踪应用数据，并在数据变化时告诉 React，这也意味着你得做更多工作**。

:::tip
整个过程本质上就是用 Scheduler 去调度任务的优先级，高优任务优先进入 Reconciler，然后 Reconciler 找出变化的组件，当 Scheduler 将任务交给 Reconciler 后，Reconciler 会为变化的虚拟 DOM 打上代表增/删/更新的标记

一个 DOM 节点在某一时刻最多会有 4 个节点和他相关：

- current Fiber。如果该 DOM 节点已在页面中，current Fiber 代表该 DOM 节点对应的 Fiber 节点
- workInProgress Fiber。如果该 DOM 节点将在本次更新中渲染到页面中，workInProgress Fiber 代表该 DOM 节点对应的 Fiber 节点
- DOM 节点本身
- JSX 对象。即 ClassComponent 的 render 方法的返回结果，或 FunctionComponent 的调用结果。JSX 对象中包含描述 DOM 节点的信息

Diff 算法的本质是对比 1 和 4，生成 2。
:::

## 状态管理方案

- 没有状态管理：直接用 props 或者 context
- 单项数据流：redux
- 双向绑定：mobx

### props/context

直接用 props ，React 原生只支持父子通信（父组件可以直接将 this.props 传入子组件）还有子父通信（父组件传递给子组件的是一个绑定了自身上下文的函数，那么子组件在调用该函数时，就可以将想要交给父组件的数据以函数入参的形式传给父级作用域），但是项目越大，会越来越麻烦。

对于 context，会存在一些性能问题，只要 context 的 value 发生变化，所有消费该 context 的组件都会 re-render。不过可以拆分 context+useMemo 来解决一些问题。

### redux

对于 redux，三大原则：1. 单一数据源、2. 纯函数 Reducer、3. State 是只读的，总的来说就是定义 action、reducer，通过 dispatch 来触发更新。

:::tip
纯函数是指：

- 相同输入总是会返回相同的输出
- 不产生副作用：副作用就是指外部交互，比如 ajax 请求
- 不依赖于外部状态

:::

### Mobx

对于 Mobx，Mobx 通过监听数据的属性变化，可以直接在数据上更改触发 UI 的渲染。

以 Mobx 5 为分界点，5 以前采用 Object.defineProperty 的方案，5 及以后使用 Proxy 的方案。最大的优点就是响应式自动更新数据。

## 写个 redux

```shell
npm init @vitejs/app
```

Redux 的三个核心概念：

- 整个应用的 state 被储存于唯一一个 store 中
- 唯一改变 state 的方法就是触发 action
- 需要用 reducers 来描述 action 如何改变 state

然后，再介绍一下 Redux 的 Store 提供的方法：

- 提供 getState() 方法获取 state；
- 提供 dispatch(action) 方法更新 state；
- 通过 subscribe(listener) 注册监听器;
- 通过 subscribe(listener) 返回的函数注销监听器。

构造一下 createStore 函数：

```js
const createStore = (reducer, preloadedState) => {
  let state = preloadedState;
  const listeners = new Set();
  // 提供 dispatch(action) 方法更新 state；
  const dispatch = (action) => {
    state = reducer(state, action);
    listeners.forEach((listener) => listener());
  };
  // 提供 getState() 方法获取 state
  const getState = () => {
    return state;
  };
  // 通过 subscribe(listener) 注册监听器
  const subscribe = (listener) => {
    listeners.add(listener);
    return unsubscribe(listener);
  };
  // 通过 subscribe(listener) 返回的函数注销监听器
  const unsubscribe = (listener) => {
    return () => {
      listeners.delete(listener);
    };
  };
  return {
    dispatch,
    subscribe,
    getState,
  };
};
```

使用方法如下：

```js
// 需要用 reducers 来描述 action 如何改变state
const reducer = (state = { count: 0 }, action) => {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
};
const store = createStore(reducer);
const unsubscribe = store.subscribe(() => {
  // 回调中用 getState 获取最新 state
  const state = store.getState();
  console.log(state.count);
}); // 唯一改变 state 的方法就是触发 actionstore.dispatch({ type: "increment" })

unsubscribe();
```

上面代码定义的 store 可在 React 组件中使用，当 store 发生变化，强制组件重新渲染：

```jsx
const Counter = () => {
  const [, forceUpdate] = React.useState();
  useEffect(() => {
    const unsubscribe = store.subscribe(() => {
      // store 发生变化，组件强制重新渲染
      forceUpdate({});
    });
    return () => {
      unsubscribe();
    };
  }, []);
  return (
    <div onClick={() => store.dispatch({ type: "increment" })}>
      {store.getState()?.count || 0}
    </div>
  );
};
```

上面已经实现了一个简单的 Redux，为了使用起来更方便，进一步实现一个简单的 React-Redux。首先定义 Provider 组件：

```jsx
const ReduxContext = React.createContext();
const Provider = ({ store, children }) => {
  const contextValue = useMemo(() => ({ store }), [store]);
  useEffect(() => {});
  return (
    <ReduxContext.Provider value={contextValue}>
      {children}
    </ReduxContext.Provider>
  );
};
```

在 Provider 中使用 Context 实现各个子组件之间共享 store 数据；connect 消费 Context 并且在 store 的值变化时，强制重新渲染组件：

```js
const connect = (mapStateToProps, mapDispatchToProps) => {
  return (Component) => {
    return (props) => {
      const [, forceUpdate] = useState({});
      const { store } = useContext(ReduxContext);
      const stateToProps = mapStateToProps(store.getState());
      const dispachToProps = mapDispatchToProps(store.dispatch, props);

      useEffect(() => {
        store.subscribe(() => {
          // store 的值变化时，强制重新渲染组件
          forceUpdate({});
        });
      }, [store]);
      return <Component {...props} {...stateToProps} {...dispachToProps} />;
    };
  };
};
```

connect 作为一个高阶组件，将 store 中的数据和方法映射到组件的 props 上，而且当 store 变化时更新组件。

使用方法如下：

```js
const Counter = (props) => {
  return <div onClick={props.onClick}>{props.count}</div>;
};
const CounterWrap = connect(
  (state) => ({ count: state.count }),
  (dispatch) => ({
    onClick: () => {
      dispatch({ type: "increment" });
    },
  })
)(Counter);
const App = () => {
  return (
    <Provider store={store}>
      <CounterWrap />
    </Provider>
  );
};
```
