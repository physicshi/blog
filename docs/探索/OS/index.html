<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.5">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="我的秘密基地 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="我的秘密基地 Blog Atom Feed"><title data-react-helmet="true">OS | 我的秘密基地</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://physicshi.github.io/docs/探索/OS"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="OS | 我的秘密基地"><meta data-react-helmet="true" name="description" content="从零开始的操作系统"><meta data-react-helmet="true" property="og:description" content="从零开始的操作系统"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://physicshi.github.io/docs/探索/OS"><link data-react-helmet="true" rel="alternate" href="https://physicshi.github.io/docs/探索/OS" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://physicshi.github.io/docs/探索/OS" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.28eae8ec.css">
<link rel="preload" href="/assets/js/runtime~main.3f4cb4ea.js" as="script">
<link rel="preload" href="/assets/js/main.c78f278f.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_RZKW">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_RFGx themedImage--light_Ble8 navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_RFGx themedImage--dark_wwiP navbar__logo"><b class="navbar__title">秘密基地</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">笔记📒</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/physicshi" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_mu0C"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_nWAW react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_MFxJ">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_MFxJ">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_IIrL"><button class="clean-btn backToTopButton_x+Rm" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_psz0"><div class="sidebar_aYCW"><nav class="menu thin-scrollbar menu_h+Ol menuWithAnnouncementBar_GKH3"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/intro">写在前面</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">浏览器</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">CSS</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">JavaScript</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Webpack</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Vite</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Babel</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">React</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">NodeJS</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">不只是前端</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">探索</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/探索/Rust">Rust</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/探索/Go">Go</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/探索/MySQL">MySQL</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/探索/Nginx">Nginx</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/探索/Docker">Docker</a></li><li class="menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/探索/OS">OS</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/探索/部署">部署</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/探索/CookieSessionToken">CookieSessionToken</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/探索/一些面试">一些面试</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">leetcode</a></li></ul></nav></div></aside><main class="docMainContainer_jMVY"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_+GTl"><div class="docItemContainer_RH7h"><article><div class="tocCollapsible_y1bX tocMobile_zI+Y"><button type="button" class="clean-btn tocCollapsibleButton_U+cm">On this page</button></div><div class="markdown"><header><h1>OS</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_jJj8" id="从零开始的操作系统"></a>从零开始的操作系统<a class="hash-link" href="#从零开始的操作系统" title="Direct link to heading">#</a></h2><p>首先给操作系统下一个定义：</p><ul><li>操作系统就是计算机硬件之上的一层软件，帮助用户和应用程序使用和管理计算机的资源，方便、高效的使用硬件（比如使用显存，打开多个终端）。</li></ul><p><img src="https://tvax2.sinaimg.cn/large/006T9etDly1h1bijbhbwxj308y0b6aas.jpg" alt="image"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_jJj8" id="历史"></a>历史<a class="hash-link" href="#历史" title="Direct link to heading">#</a></h2><p>操作系统历史，IBM7094 的操作系统（确切的说是监控系统）做的事情就是如果发现一个任务中途出错或者完成了，就切到另外一个任务去执行（修改 PC）——一个作业完成自动读入下一个作业（批处理），作业输入磁带计算结果输出磁带。</p><p>到了 IBM OS/360，计算机进入多个行业，需要让计算机做多种事，所以原来的批处理无法满足，因为既有 IO 任务又有计算任务（我们知道 IO 操作是比较慢的，等待 IO 完成再去执行下一个计算任务显然是不合理的），多道程序交替推进，出现了作业之间的切换和调度，需要让 CPU 忙碌。</p><p>后来出现了基于 OS/360 的多道程序、来回切换的思想实现的其他操作系统——MULTICS，考虑到计算机不仅是进入多个行业，还会有多个人同时使用，思想就是：沿用了任务切换的思想，引入了分时系统，即每个用户启动的计算任务对应一个多道程序，通过切换来让每个用户的任务都得到执行，在切换的时候引入时间片概念，即给每个用户分配一个固定大小的时间片 T ，用完这个时间片以后将 CPU 切换给下一个用户（而不是之前基于 IO 操作的切换），这个概念的提出，使得一个计算机可以很多个人同时使用，对于服务器来说很重要（多个人登陆共同使用系统）</p><p>UNIX 时代，随着计算机硬件的发展，个人计算机开始出现 IBM PDP-1，Thompson、Ritchi 在一台没人使用的 PDP-7 上开发 了一个简化的 MULTICS，这就是后来的 UNIX，核心思想类似 MULTICS 或者说 OS/360，但更加小巧、灵活同时也更加可靠，UNIX 大获成功，被应用到了各种场合中</p><p>Linux 时代，1987 年 Tanenbaum 发布了 MINIX 系统 (基本概念类似于 UNIX) 用 于教学，21 岁的 Linus 在 IBM 386SX 兼容机上学习了 MINIX，做出了一个小 Linux 并于 1991 年发布，1994 年 Linux 1.0 发布并采用了 GPL 协议，1998 年以后互联网展开了一场历史性的 Linux 产业化运动</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="从人机交互的角度讲操作系统历史"></a>从人机交互的角度讲操作系统历史<a class="hash-link" href="#从人机交互的角度讲操作系统历史" title="Direct link to heading">#</a></h3><p>ltair 8800 是 基于 Intel 8080 所设计的 PC，在 1974 年发布。</p><p>1975 年 Digital Research 公司为 Altair 8800 开发了一个操作系统 CP/M(Control Program for Microcomputers)。</p><p>22 岁的 PaulAllen 和 20 岁的 BillGates 为 Altair 8800 开发了 BASIC 解释器，以及 FAT 文件系统来管理磁盘，1981 年微软买下 QDOS(Quick and Dirty Operating System，该系统是由 Tim Paterson 以 CP/M 的基本思想为基础花费 6 个星期写出来的)，改名为 MS- DOS(Microsoft Disk OS)。</p><p>接着 IBM 与微软合作，MS-DOS 和 IBM PC 打包一起 出售。MS-DOS 中磁盘、文件、命令等概念已经让用户可以方便地使用自己的 PC 机了。</p><p>1989 年，MS-DOS 4.0 出现，已经可以支持鼠标的点击，但此时微软已经决定要放弃 MS-DOS，不久后微软发布了基于图形界面的 Windows 3.0...</p><p>苹果 IOS 与 windows 类似，也是关注于人机交互，Mac OS 底层内核使用的是 UNIX 操作系统，Mac OS 将主要精 力集中于界面、文件、媒体等和用户交互直观有关的内容上（1984 年，苹果也推出了自己的个人计算机，被称为麦金 塔机(Macintosh)，简称 Mac 机，其处理器直接使用 IBM、Intel 或 AMD 等公 司推出的 CPU，而苹果公司专注于屏幕、能耗等直接和用户体验相关的硬件，与 Mac 机一起发布的操作系统是图形界面操作系统 System X，后来改名为 Mac OS）。</p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</h5></div><div class="admonition-content"><p>CP/M-&gt; QDOS -&gt; MS-DOS -&gt; Windows</p><p>Unix -&gt; System X-&gt;Mac OS -&gt; IOS</p></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_jJj8" id="系统调用"></a>系统调用<a class="hash-link" href="#系统调用" title="Direct link to heading">#</a></h2><p>首先引出操作系统接口这个概念，在这里，接口就是连接应用与操作系统的，操作系统接口表现为函数调用，是由操作系统提供的函数，操作系统接口又叫系统调用。上层应用程序利用操作系统接口，进入操作系统，使用操作系统功能。</p><p>操作系统接口是由 IEEE 制定的标准（为了使不同的操作系统提供相同的系统调用），叫做 <code>POSIX</code>，考虑到上层的应用程序无非是系统调用+一些代码，系统调用标准化后，可以实现跨平台。</p><p>有哪些具体的操作系统接口呢？通常有任务管理类比如 <code>fork()</code>、文件系统类比如 <code>open()</code> 等。</p><p>应用程序在内存中，操作系统也在内存中，应用程序想访问操作系统提供的功能为什么不能直接去找对应内存地址，拿数据或者访问呢，而非要通过系统调用？变成函数调用而非系统调用——太不安全了，随意调用内核的数据，应用程序会随意访问修改 root 密码等等。</p><p>这种隔离怎么做到的？以及怎么进入内核中呢？</p><p>其实这是处理器的硬件设计，区分了用户态和内核态（内核态是操作系统代码执行时的状态，用户态是应用程序代码执行时的状态，0 是内核态，3 是用户态），对应的内存区域是用户段与内核段。这里数字越小表示权限越高，只有当前的特权级（CPL）小于等于目标的特权级（DPL），也就是 DPL&gt;=CPL，比如 0&gt;=0、3&gt;=0，执行的指令才会被允许。所以内核态可以访问任意数据，用户态不能访问内核数据。</p><p>实际上硬件提供了主动进入内核的方法：对于 Intel x86，操作系统提供了中断指令 int 0x80 来主动进入内核，这是用户程序发起的调用访问内核代码的唯一方式。发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序（内核来响应中断），内核程序开始执行，也就是开始处理系统调用。
这里系统调用的核心就是：</p><ol><li>用户程序中包含一段 int 指令的代码，通常是由库函数通过内联汇编插入</li><li>操作系统写中断处理，获取想调用程序的编号</li><li>操作系统根据编号执行相应的代码</li></ol><p>具体来说调用系统函数时会通过内嵌汇编代码插入 int 0x80 的中断指令，其实不仅插入中断指令，还将系统调用号置给 %eax 寄存器，整个过程核心就是，将一个系统调用号置给%eax，然后调用 int 0x80，调用 int 0x80 就到了内核了</p><p>内核接收到 int 0x80 中断后，需要查询 IDT 表（中断描述符表）来取出中断处理函数地址，这里注意操作系统在初始化 0x80 中断处理时故意将其 DPL 设置为 3，所以可以在用户态直接访问 int 0x80 的中断指令。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_jJj8" id="进程管理"></a>进程管理<a class="hash-link" href="#进程管理" title="Direct link to heading">#</a></h2><p>CPU 的工作原理就是不断地取指执行、再取指再执行，将一段程序放到内存中，然后将 PC 指针 设置为这段程序的起始地址，接下来 CPU 就开始不断的取指执行，CPU 就开始工作，但是这样 CPU 利用率不高，理想状态是多道程序交替执行，CPU 变得忙碌，CPU 上交替执行多个程序——并发（多个程序同时出发，交替执行的结构），管理 CPU 应该让 CPU 并发的去执行程序。</p><p>现在的问题是怎么实现这个图像？仅仅修改 PC 指针并不可以做到，我们还需要将需要将曾经执行的信息保存起来（比如为了保证切换后的运行结果正确），并且要将切出去时的执行地址保存起来（这样才可以知道下一个指令地址）。</p><p>所以在 PC 切换的时候，需要保存一些信息，并且需要将这些信息和相应程序关联起来，就是说一个程序要带着一个数据结构才能执行起来、才能在多个这样执行起来的程序之间来回切换，这个数据结构保存了这个程序当前执行位置、执行现场等重要信息（这是执行时的程序和静态程序的区别），这就引出了进程概念，进程是进行（执行）中的程序。</p><p>这种多个进程之间的切换——多进程图像，实现了并发、实现 CPU 的高效管理。</p><p>多进程图像是操作系统的核心图像，有了进程概念可以对 CPU 管理重新描述——要高效管理 CPU，需要启动多个进程，并能多个进程之间调度、切换（所以 CPU 管理又叫进程管理）。</p><p>实际上多进程图像在启动 PC 到结束 PC 的整个生命周期一直存在，操作系统要让用户使用计算机，就是创建一个初始化的进程（返回一个 shell/桌面 <code>if(!fork()){init();}</code>），接下来用户执行一个任务（命令）就是创建一个进程（可能这个任务还会启动多个进程 <code>if(!fork()){exec(cmd);}</code>）。所以每解决一个任务，计算机都会启动一个进程，来执行这个任务，用户启动计算机，就是启动一堆进程，用户管理计算机就是管理这堆进程。另外一个问题就是多进程如何组织，实际上操作系统感知进程、组织进程依赖于 PCB（进程控制块），PCB 就是用来记录进程信息的数据结构，组织进程就是用队列来管理相应的 PCB，多个进程对应的 PCB 分别放在合适的队列，比如就绪队列就是在等待 CPU 空闲、磁盘等待队列是在等待磁盘读写完成。
更具体的，可以用进程状态来对操作系统中的进程进行分类。进程的状态主要分为三类:</p><ol><li>运行态 当前占有 CPU 正在执行的进程状态;</li><li>就绪态 一个进程具备了所有可以执行的条件，只要获得 CPU 就能开始执行;</li><li>阻塞态 一个进程因为缺少某些条件，即使分配了 CPU 也无法执行的状态。</li></ol><p>有了这三个状态，就相应的产生了三个 PCB 队列:运行队列;就绪队列和阻塞队列。</p><p>如果以单 CPU 为背景，只有一个 CPU 就是说只有一个处于运行状态的进程。另一方面，由于等待的事件可能有多个，比如磁盘读写、打印机等等，相应的就有多个阻塞队列。就绪队列中的进程都只是等待 CPU，所以只有一个就绪队列。</p><p><img src="https://tva2.sinaimg.cn/mw690/006T9etDly1h2hicne7eaj30vu0iuq5p.jpg" alt="image"></p><p>利用进程状态还可以描述一个进程在其执行过程中的演化过程，又叫进程的生命周期。利用进程的状态转移可以清晰的描述这个演化过程，进程的基本状态转移图：</p><p><img src="https://tvax3.sinaimg.cn/mw690/006T9etDly1h2hidqo09gj31ma0nm431.jpg" alt="image"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="用户级线程"></a>用户级线程<a class="hash-link" href="#用户级线程" title="Direct link to heading">#</a></h3><p>进程指的是执行中的程序，这里意味着进程包括资源+指令执行序列，进程切换由资源切换和指令流切换两部分构成，其中资源切换是将分配给进程的非 CPU 以外的资源进行切换，如对当前地址空间的切换;而指令流切换就是 CPU 切换，也就是线程切换。直观地说，比如在同一个可执行文 件内，两个函数之间也可以交替，如在同一个浏览器内部有两个函数 <code>GetData()</code> 和 <code>Show()</code>，这两个函数也可以交替执行，这样的交替执行就产生了线程概念。
所以线程保留了并发的优点，避免了进程切换代价——因为不需要切资源（映射表），多个线程在同一个进程资源下。这里，线程与进程的区分就是是否使用不同的“进程资源”。</p><p>线程就是要在一个地址空间下启动并交替执行的多个执行序列。执行序列就是一段执行中的程序，这多段程序完全可以只出现在用户态程序中，即操作系统完全不知道这些线程的存在，这样的线程被称为用户级线程。和用户级线程概念相对应的是内核级线程，能在同一地址空间中交替执行并交由操作系统管理的执行序列就是内核级线程。</p><p>用户级线程的切换需要完成线程 TCB 的切换和栈切换（注意这里一个线程对应一个栈）。此外用户级线程是完全在用户态内存中制造的一个指令执行序列，即用户级线程的 TCB、栈等内容都是创建在用户态中的，操作系统完全不知道。</p><blockquote><p>明确没有用户级进程这个概念，因为要为进程分配资源，访问内存/文件，这些都要到内核态下才能完成的</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="内核级线程"></a>内核级线程<a class="hash-link" href="#内核级线程" title="Direct link to heading">#</a></h3><p>内核级线程，操作系统对用户级线程是没有感知的，只会利用处理器的一个核来执行指令序列（即使切换线程也始终是一个核工作），这样对硬件的利用效率是比较低的。</p><p>但是如果是两个内核级线程，此时操作系统能操纵两个指令执行序列，会将核 1 分配给第一个执行序列，核 2 分配给第二个执行序列，两个核可以同时取指执行，硬件工作效率得到显著提升。可以做到并行。</p><p>但是如果是两个进程，因为多核处理器中的多个核通常要共享 MMU(Memory Management Unit，内存管理单元) 以及一些缓存等，为了避免进程之间的影响，进程之间要实现地址隔离，即每个进程要使用自己的地址空间和地址映射表，硬件 MMU 就是用来查找地址映射表的硬件，而某些缓存就用来缓存一些最近的地址映射结果。</p><p>如果将两个进程并行地放在一个多核处理器的两个核上，考虑到共享 MMU 不能同时去查两个不同的表，而且缓存也不能发挥作用。不过两个内核级线程使用的是同一个地址空间，MMU、缓存本身都是可以共享的。所以内核级线 程非常适合于多核处理器结构，而多核处理器是现代处理器设计中的一种主流技术，因此绝大多数现代操作系统都支持内核级线程。</p><p>用户级线程、内核级线程、进程这三者的内在关系是:</p><p>(1)引出进程的目标是为了管理 CPU，即通过执行程序来使用 CPU。进程、内核级线程、用户级线程都是要执行一个指令序列，没有本质区别，所以这三者都属于 CPU 管理范畴;</p><p>(2)要执行一个指令序列，除了通过分配栈、创建数据结构记录执行位置等以外，还要分配内存(显然要分配内存并将指令序列读入内存以后，程序才能被“取指执行”)等资源，这就是进程的概念;</p><p>(3)将进程中的资源和执行序列分离以后引出了线程概念，进程必须在操作系统内核中创建，这是因为进程创建要涉及到计算机硬件资源的分配。因此进程中的那个执行序列实际上就是一个内核级线程;</p><p>(4)内核级线程是操作系统在一套进程资源下创建的可以并发执行的多个执行序列，操作系统为每个这样的执行序列创建了相应的数据结构来实现对这些内核级线程控制，如切换、调度等;</p><p>(5)同样的，上层应用程序也可以创建并交替执行多个指令执行序列，因为执行程序所需要的资源已经在创建进程时分配好了。此时启动多个执行序列所需要的 TCB 和用户栈等信息完全可以由应用程序自己编程实现，由应用程序负责操控这多个执行序列，对操作系统而言完全透明。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="进程同步与信号量"></a>进程同步与信号量<a class="hash-link" href="#进程同步与信号量" title="Direct link to heading">#</a></h3><p>进程同步的基本内容就是一个进程在需要同步的地方停下来等待依赖进程，发现依赖进程完成了和同步对应的工作以后，这个进程再继续向前执行。从定义上来说，进程同步就是通过对进程走走停停(等待和唤醒)的控制来让多个进程步调一致，合理有序的向前推进，完成相互依赖、相互合作。</p><p>关于信号与信号量，可以借用生产者和消费者模型：</p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</h5></div><div class="admonition-content"><p>生产者消费者模型，是指在一个系统中，存在生产者和消费者两种角色，他们通过内存缓冲区进行通信，生产者生产消费者需要的资料，消费者把资料做成产品</p><p>内存缓冲区满了之后，生产者没办法继续往内存区生产东西，消费者需要消费内存区的内容，才会让内存区空出位置。</p><p>生产者在缓存区满了以后会睡眠等待，此处要定义一个信号量（表示缓冲区空闲的 item 数），当这个信号量的数值为 0 时，生产者要执行 P 操作以后会睡眠等待。所以此处定义的信号量是用 0 来表示缓存区满。因此这个信号量表达的含义就应该是缓存区中空闲单元的个数，所以可以命名为 empty，初值为 BUFFER_SIZE，生产者对 empty 信号量执行 P 操作，而消费者对 empty 信号量执行 V 操作。</p><p>类似的，可以分析出消费者进程在缓存区中没有 item 时会阻塞，所以对应的信号量为 0 时要表达出缓存区中没有 item 这样的语义，所以该信号量要表达的含义就是缓存区中的 item 个数，可命名为 full（缓冲区的 item 总数），初值为 0。</p><p>另外，由于是共享缓存区，当某个进程进入共享缓存区进行修改时，其他进程不能使用缓存区的，只能睡眠等待。有睡眠等待就是一个同步点，因此需要再定义一个信号量来实现这个同步点。由于只能让 1 个进程修改缓存区，所以这个信号量的初值应该为 1，一旦某个进程进入以后就应该将其减为 0 (对应 P 操作)。此时当其他进程再想修改缓存区时，对该信号量的 P 操作会导致进程阻塞等待。根据语义，这个信号量的含义是互斥进入，所以将其命名为 mutex，初值为 1。</p></div></div><p>信号量(Semaphore)就是在信号上关联的一个整数，可以根据这个整数来决定进程的阻塞的唤醒。</p><p>信号量就是一个数据对象以及操作这个数据对象的两个操作，其中数据对象是信号量数值以及相应的阻塞进程队列，而在这个数据对象上的两个操作就是对信号量数值的加 1 和减 1，并根据加减后的信号量数值决定的睡眠和唤醒。</p><p>特点：</p><ol><li>信号量就是一个整型变量，用来记录和进程同步有关的重要信息</li><li>能让进程阻塞睡眠体现在这个信号量上</li><li>需要同步的进程通过操作（加 1 和减 1）信号量实现进程的阻塞和唤醒，即进程间的同步</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="信号量的临界区保护"></a>信号量的临界区保护<a class="hash-link" href="#信号量的临界区保护" title="Direct link to heading">#</a></h3><p>回顾一下信号量（信号量最重要的就是有正确的语义），信号量的作用就是根据信号量数值表达出来的语义来决定进程的停与走（睡眠和唤醒）。比如信号量的当前值为 -1，表达出来的语义就是现在有一个进程等待在这个信号量上，如果再来一个进程执行 P 操作(即要继续减 1，相当于继续申请资源)，此时该进程应该睡眠等待在该信号量上。而如果再来的进程执行的是 V 操作(即要给信号量加 1，相当于释放资源)，则唤醒睡眠在该信号量上的一个进程。</p><p>这里的关键是信号量的数值时刻。与信号量对应的语义信息保持一致，才能正确地使用信号量来决定进程的同步(停与走)。但是对于同时存在于操作系统中的多个并发进程会竞争使用 CPU，竞争会导致各种各样的调度结果。有些调度顺序很可能导致共享变量出现语义错误（比如生产者-消费者模型中，两个生产者竞争修改信号量 empty 时可能出现的语义错误）。注： empty 缓存区中空闲单元的个数，初值为 BUFFER_SIZE，生产者对 empty 信号量执行 P 操作——继续申请资源，而消费者对 empty 信号量执行 V 操作——相当于释放资源。</p><p>解决这个竞争问题的关键在于：每个进程对信号量的修改要么一点不做，要么全部做完，中途不能被打断，即对信号量的修改必须是一个原子操作。</p><p>在计算机软件系统中，无论增加什么机制，最终的表现都是增加了代码。所以保护信号量的的机制就是在修改信号量的代码基础上“包裹”其他代码来让信号量的修改操作成为原子操作</p><p>这里引入临界区的概念，临界区就是进程中的一段代码，这段代码和其它相关进程中的相关代码对应，一次至多只允许一个进程进入，即互斥进入。</p><p>之所以被称为临界区，是因为一旦进入了这段代码，操作系统的状态就发生了改变，现在就不能在进程之间随意切换了，而执行进程中的其它代码时是可以随意切换的</p><p>有了临界区概念以后，信号量保护的实质就是让进程中修改信号量的代码变成为临界区代码</p><p>在修改信号量代码前面加上进入区代码，在修改完信号量以后调用离开区代码，从而实现一次只能有一个进程对信号量的修改，保证信号量修改的原子性，保证信号量的语义始终保持正确。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="死锁处理"></a>死锁处理<a class="hash-link" href="#死锁处理" title="Direct link to heading">#</a></h3><p>首先死锁是指多个进程由于互相等待对方持有的资源而造成的谁都无法执行的情况。</p><p>所以死锁的成因直观上就是</p><ol><li>资源的互斥使用，一旦占有别人就无法使用；</li><li>进程占有了一些资源，又不去释放，再去申请其他资源；</li><li>各自占有的资源和互相申请的资源形成了环路等待</li></ol><p>这里总结的死锁有四个必要条件：</p><ol><li>互斥使用：资源的固有属性</li><li>不可抢占：资源只能资源放弃</li><li>请求和保持：进程必须占有资源（保持住），再去申请</li><li>循环等待：在资源分配图中存在一个环路</li></ol><p>死锁的处理方法，大致有四个：</p><ol><li>死锁预防，破坏死锁出现的条件</li><li>死锁避免：检测每个资源请求，如果造成死锁就拒绝</li><li>死锁检测与恢复：检测到死锁出现时，让一些进程回滚，让出资源</li><li>死锁忽略（考虑到死锁出现是不确定的，又可以用重启来处理死锁）</li></ol><p>具体来讲，死锁预防的例子：</p><ol><li>可以在进程执行前，一次性申请所有需要的资源，不会占有资源再去申请其他资源但是会有缺点：许多资源在分配后很长时间才使用，资源利用率低</li><li>或者可以对资源类型进行排序，资源申请必须按序进行，不然会造成环路等待，也有明显的缺点：资源浪费</li></ol><p>对于死锁避免：如果系统中的所有进程存在一个可完成的执行序列，则称系统处于安全状态。找到安全序列的银行家算法（但是复杂度太高 <code>O(mn^2)</code> m 种资源，n 个进程）</p><p>对于死锁检测与恢复，思想就是发现问题再处理：考虑到每次申请都执行 <code>O(mn^2)</code>，效率低。所以可以定时检测或者发现资源利用率低时检测</p><p>对于死锁忽略，考虑到死锁预防引入太多不合理因素（浪费资源），死锁避免每次都执行银行家算法 <code>O(mn^2)</code> 效率太低，死锁检测与恢复：恢复很不容易，进程造成的改变很难恢复，所以引出了死锁忽略——死锁出现是不确定的，又可以用重启来处理死锁</p><p>实际上很多 PC 采用的都是死锁忽略</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_jJj8" id="内存管理"></a>内存管理<a class="hash-link" href="#内存管理" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="内存使用与分段"></a>内存使用与分段<a class="hash-link" href="#内存使用与分段" title="Direct link to heading">#</a></h3><p>内存使用直观上就是将程序放到内存中，PC 指向开始地址。计算机工作的基本过程就是，CPU 在内存中不断地取出并执行指令。</p><p>但是我们不可能是在 0 地址位置开始，因为 0 地址已经被操作系统占用了，所以思路是利用相对地址。</p><p>核心就是：在物理内存中找一段空闲区域，比如找到从地址 1000 处开始的一段内存，然后将可执行文件读入到从地址 1000 开始的这段物理内存区域，设置 PC = 1000 开始执行。但在执行指令“call 40”时实际要执行的指令应该是”call 1040“。 由此可以看出，这里的核心工作就是要将“call 40（这里是逻辑地址）”修改成“call 1040（真实地址）”，这个过程对应一个著名概念 程序重定位——将程序中的逻辑地址对应到实际使用的物理内存地址。</p><p>程序重定位一般有两种方式：</p><ol><li>编译时重定位——编译产生可执行代码时，就要将程序中出现的逻辑地址全部加上 1000 以后再写入可执行文件。显然这个编译时重定位的可执行程序只能载入到从地址 1000 处开始的物理内存区域中，只有那些执行固定任务的计算机系统才能在编译时就预先已知将来的执行位置，例如卫星上工作的计算任务通常都是在地面上就已经固定好的</li><li>载入时重定位——就是在程序载入时，根据载入的物理内存地址区域来修改程序中的逻辑地址。如果程序被载入到地址 1000 处开始的物理内存区域，地址 40 就被修改为 40 + 1000 = 1040;如果被载入到了地址 2000 处开始的物理内存区域，地址 40 就被修改为 40 + 2000 = 2040</li></ol><p>但在进程的执行过程中，进程会换入换出，所以实际上载入时重定位还是不够灵活：程序一旦载入到物理内存以后，就不能在内存中移动了，因 为如果程序代码从 1000 出挪动到 2000 处以后，已经修改过的指令“call 1040” 显然就不好使了</p><p>运行时重定位，即在指令执行时才将指令的逻辑地址翻译成物理地址。具体做法也不难想到:程序载入内存执行(即进程创建)时，寻找一段空闲内存区域将程序放入，并记录下这段内存区域的基地址。每执行一条指令，都先将指令中的逻辑地址加上基地址以后才放在地址总线上</p><p>也就是说每次执行一条指令都要从逻辑地址算出物理地址——地址翻译，每个进程有各自的基地址，放到 PCB 里，执行指令的第一步就是从 PCB 中取出这个基地址，进程切换时将其 PCB 中存放的基地址取出来赋给 CPU 的重定位基址寄存器</p><p>通过切换 PC 让多个进程中的指令交替执行，通过切换基址寄存器切换进程工作的内存空间</p><p>考虑程序载入内存，首先程序并不会整块载入，程序由若干段组成，如代码段、数据段、栈段等。每个段有各自的特点和用途，代码段是程序指令形成的段，代码段只读；数据段中存放程序使用的数据，数据段可读可写;栈段用来实现函数调用，栈通常只能向下增长。</p><p>其实分段是分治的思想，程序的基本结构就是定义一些数据变量、并对这些数据执行相应的操作、通常每个操作对应一个函数、用函数调用实现数据上的多个操作（在这样的基本程序结构下，程序员通常要分开思考：要定义哪些数据?在这些数据上执行哪些操作？操作对应的函数之间如何嵌套调用?）</p><p>整个程序载入内存，需要记录一个基地址，分段以后，需要将多个段分别载入内存，要记录每个段的基地址，多个基地址就会形成一个表，这就是著名的段表。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_jJj8" id="内存分区与分页"></a>内存分区与分页<a class="hash-link" href="#内存分区与分页" title="Direct link to heading">#</a></h3><p>操作系统的基本内容包括进程管理、内存管理、设备驱动以及文件系统（磁盘管理），内存管理其实就是将程序载入到内存并经过重定位以后，指令在内存中顺利执行。但是这些还有一个前提：要将程序载入到内存，首先要要在内存中分割出一段空闲内存。</p><p>考虑到核心是分割内存区域，所以该算法一般叫做内存分区（可变分区），要做的事情非常直接：针对一个段请求，从当前的空闲内存区域中 找一个能满足请求，即大于请求尺寸的内存区域，然后在这个区域中割出一段和请求尺寸大小相等的内存区域进行分配。至于叫可变分区的是因为 请求放入内存的段尺寸不固定，分割的内存区域也不是固定大小的</p><p>因为操作系统中的进程不仅申请内存，在进程执行过程中也会释放内存(比如进程退出)，所以操作系统中经常会有很多块空闲内存区域，至于下一个段请求会进入哪一个内存区域，一般有三种策略（分区适配算法）：</p><ol><li>最佳适配 O(n)</li><li>最差适配 O(n)</li><li>最先适配 O(1)；</li></ol><p>总结一下：操作系统为了让程序能够使用起来，将程序打成了多个段，每个段放在内存的不同空闲地方，所以要在内存中找到哪些地方是空闲的，为了找到哪些地方空闲需要做两件事：</p><ol><li>维护空闲分区表（记录和维护哪些内存区域空闲的信息）</li><li>分区空闲算法</li></ol><p>注意实际系统中并不使用内存分区来进行物理内存的分割，而是通过分页来做的，因为分区还是会面临一些问题：多个小区域合起来很大，但每个小区域本身又太小、无法分配。现在的策略是内存分配本身就是以小区域(小片)为单位的。</p><p>这就是分页机制的基本思想，这里的小片就是内存页，因此，分页机制是解决内存碎片问题而提出的重要方法，可以有效提高内存的空间使用效率，所以通常的操作系统都支持分页机制——将内存请求打散，比如以 10K 为单位打散，那么 160K 请求就是 16 片，150K 的空闲内存区域能满足 15 片请求，然后在 50K 空闲内存 区域上分配 1 片，160K 的内存请求就能全部满足</p><p>分页机制首先将物理内存分割成大小相等的页框，然后再将请求放入物理内存的数据(比如代码段)也分割成同样大小的页，最后将所有页都载入到(映射到)页框上，完成物理内存页框的使用</p><p>不过要真正让内存中的程序可被取指执行、让内存中的数据可被寻址读写，还需要解决重定位问题，</p><p>比如这里就是 0x2240 除 4K（商是页数，余数是偏移——你占的大小），其实就是右移 12 位，16 进制的一位相当于四个二进制位 0x2240/4k 就是 0x02 就是页数，0x240 就是偏移</p><p>总结：一个程序是由多个段组成，每一个段如果直接放到内存会造成内存碎片（需要内存紧缩，但是会很耗时，并且会造成 os 停顿），所以一个段要打散成多个页，每个段要放到内存的多个页中，为了找到程序执行时的物理地址（重定位），还需要建立页表（当然页表和 pcb 要进行关联）</p></div><footer class="docusaurus-mt-lg"><div class="row"><div class="col"><a href="https://github.com/facebook/docusaurus/edit/main/website/docs/探索/OS.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_UQtd" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_QETb"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/探索/Docker"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Docker</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/探索/部署"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">部署 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_GySF thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#从零开始的操作系统" class="table-of-contents__link">从零开始的操作系统</a></li><li><a href="#历史" class="table-of-contents__link">历史</a><ul><li><a href="#从人机交互的角度讲操作系统历史" class="table-of-contents__link">从人机交互的角度讲操作系统历史</a></li></ul></li><li><a href="#系统调用" class="table-of-contents__link">系统调用</a></li><li><a href="#进程管理" class="table-of-contents__link">进程管理</a><ul><li><a href="#用户级线程" class="table-of-contents__link">用户级线程</a></li><li><a href="#内核级线程" class="table-of-contents__link">内核级线程</a></li><li><a href="#进程同步与信号量" class="table-of-contents__link">进程同步与信号量</a></li><li><a href="#信号量的临界区保护" class="table-of-contents__link">信号量的临界区保护</a></li><li><a href="#死锁处理" class="table-of-contents__link">死锁处理</a></li></ul></li><li><a href="#内存管理" class="table-of-contents__link">内存管理</a><ul><li><a href="#内存使用与分段" class="table-of-contents__link">内存使用与分段</a></li><li><a href="#内存分区与分页" class="table-of-contents__link">内存分区与分页</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">笔记📒</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_mu0C"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_mu0C"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_mu0C"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/physicshi" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_mu0C"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 wsgy, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.3f4cb4ea.js"></script>
<script src="/assets/js/main.c78f278f.js"></script>
</body>
</html>