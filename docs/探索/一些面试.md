---
sidebar_position: 9
---

## 包装 fs.readFile 变成 promise

> fs 是文件系统模块，负责读取文件，涉及到读取文件有两个 API：
>
> - 异步方式：fs.readFile
>   - fs.readFile("./aaa.js",{encoding: "utf-8"},(err,data)=>{})
>   - 如果不传入文件编码，data 返回的是 Buffer,可以 data.toString("utf-8")转成 string
>   - Node.js 标准的回调函数：第一个参数代表错误信息，第二个参数代表结果
> - 同步方式：fs.readFileSync
>   - const data = fs.readFileSync("./aaa.js",{encoding: "utf-8"}); console.log(data)

```js
const fs = require("fs");

const toPromise = (fn) => {
  return (...args) => {
    return new Promsie((resolve, reject) => {
      fn(...args, (err, data) => {
        if (err) reject(err);
        resolve(data);
      });
    });
  };
};

const fsPromise = toPromise(fs.resdFile);
fsPromise("./aaa/js", { encoding: "utf-8" })
  .then((data) => {
    console.log(data);
  })
  .catch((err) => {
    console.log(err);
  });
```

## 事件捕获、冒泡

W3C 标准约定了一个事件的传播过程分为三个阶段：

1. 事件捕获阶段
2. 目标阶段
3. 事件冒泡阶段

当事件被触发时，事件捕获阶段：事件从 document 穿过一层层到目标节点，事件会被目标节点接收，事件冒泡阶段：一层层回到 document。

> 我们默认是事件冒泡阶段，事件处理函数被调用。element.addEventListener(event, function, useCapture)，第三个参数可选，默认是 false，事件处理函数在事件冒泡阶段被执行，如果为 true，则在捕获阶段被执行。

事件冒泡：div 元素，即被点击的元素，最先触发 click 事件，然后 click 事件沿着 DOM 树一路向上，在经过的节点依次触发，直到到达 document 对象。

### 事件对象

#### e.currentTarget

记录了当前事件正在经过哪一个目标元素，因为事件传播是层层穿梭的。

> 如果事件处理绑定的元素，与具体的触发元素一致，那么函数中的 this、e.currentTarget、e.target 三者的值是一样的。

#### e.target

触发事件的具体元素，是事件的真正来源。

> 就算事件处理程序没有绑定在目标元素上、而是绑定在了目标元素的父元素上，只要它是由内部的目标元素冒泡到父容器上触发的，那么我们仍然可以通过 target 来感知到目标元素才是事件真实的来源。

#### e.preventDefault

这个方法用于阻止特定事件的默认行为，如 a 标签的跳转等。

```js
e.preventDefault();
```

#### e.stopPropagation

不再派发事件到其他节点。

这个方法用于终止事件在传播过程的捕获、目标处理或冒泡阶段进一步传播。调用该方法后，该节点上处理该事件
的处理程序将被调用，事件不再被分派到其他节点。

```js
e.stopPropagation();
```

## http 的发展

首先 http 协议定义了客户端发起请求，服务端响应请求的通信模式。

HTTP/1.0 的特点：

- 增加了头部字段（最开始只能传 html，增加头部字段解决了不同类型文件传输的问题）
- 每通信一次，都要经历 TCP 连接 -> HTTP 通信 -> 断开 TCP 连接。这样的每一次请求都是独立的，一次请求完成连接就会断开；

考虑到 http1.0 在有大量网络请求时，频繁的建立连接、断开连接开销太大

http1.1 的特点：

- 创建持久连接：Connection: keep-alive
  - 连接复用，保持连接直到浏览器关闭或者服务器要求断开

但是 http1.1 也有问题：

- 浏览器为了减轻服务器的压力，限制了同一个域下的 HTTP 连接数，即 6 ~ 8 个，所以在 HTTP/1.1 下很容易看到资源文件等待加载的情况，对应优化的方式就是使用多个域名来加载图片资源；
- 队头阻塞，虽然可以复用连接但是必须等到当前请求结束后才能处理下一个请求，其他请求会被阻塞住

http2.0 的特点：

- 二进制分帧，HTTP/2 将默认不再使用 ASCII 编码传输，而是改为二进制数据。客户端在发送请求时会将每个请求的内容封装成不同的带有编号的二进制帧，然后将这些帧同时发送给服务端。服务端接收到数据之后，会将相同编号的帧合并为完整的请求信息。同样，服务端返回结果、客户端接收结果也遵循这个帧的拆分与组合的过程。
- 多路复用，对于同一个域，不需要再开 6 ～ 8 个 TCP 连接，只使用一个 TCP 连接就可以进行传输，用一个连接来发送多个请求的方式称为“多路复用”。

但是 http2.0，如果客户端或服务端在通信时出现数据包丢失，或者任何一方的网络出现中断，那么整个 TCP 连接就会暂停，后面的所有数据都被阻塞。

http3.0 的特点：

- 底层依赖 UDP。UDP 相对于 TCP 而言最大的特点是传输数据时不需要建立连接，可以同时发送多个数据包，所以传输效率很高（利用 quic 协议来保证准确性）

## https SSL/TLS

https 就是在 http 的基础上增加了 ssl/tls 协议 （OSI 七层参考模型的会话层），tls 是 ssl 的版本 3。

tls 使用的是混合加密的方式，用公钥加密会话密钥，再用会话密钥加密要传输的明文，这样只有用私钥才能解密会话密钥，再用会话密钥解密加密的内容。所谓会话密钥就是本次通信临时生成的密钥，用于对称加密。但是传输公钥，可能会被窃取，为了保证公钥的合法性，还需要证书。证书就是 CA 机构用自己的私钥加密别人的公钥，这样客户端下载证书，用 CA 的公钥解密签名，确认消息发送者公钥的合法性。

**证书=公钥+服务器与 CA 信息+签名**，其中签名是由 CA 用自己的私钥加密服务器的公钥以及服务器与 CA 信息得到的

## websocket

WebSocket 使服务器端可以主动向客户端发送信息，使得浏览器具备了实时双向通信的能力。

```js
function connectWebsocket() {
  ws = new WebSocket("ws://localhost:9000");
  // 监听连接成功
  ws.onopen = () => {
    console.log("连接服务端WebSocket成功");
    ws.send(JSON.stringify(msgData)); // send 方法给服务端发送消息
  };

  // 监听服务端消息(接收消息)
  ws.onmessage = (msg) => {
    let message = JSON.parse(msg.data);
    console.log("收到的消息：", message);
    elUl.innerHTML += `<li class="b">小秋：${message.content}</li>`;
  };

  // 监听连接失败
  ws.onerror = () => {
    console.log("连接失败，正在重连...");
    connectWebsocket();
  };

  // 监听连接关闭
  ws.onclose = () => {
    console.log("连接关闭");
  };
}
connectWebsocket();
```

1. 建立在 TCP 协议之上，服务器端的实现比较容易。
2. 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
3. 没有同源限制，客户端可以与任意服务器通信。
4. 协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL。

```
ws://example.com:80/some/path
```

## min-width、max-width、width 的优先级关系

Math.max(min-width, Math.min(width, max-width))

width, max-width 谁小显示谁

min-width，width/max-width 谁大显示谁

## CDN

CDN 的全称是 Content Delivery Network，即内容分发网络。

**将用户的请求重定向到离用户最近的服务节点上**，目的就是提高响应速度。

6 个步骤

**本质上就是通过修改 DNS 来选择合适的 CDN 缓存服务器来获取资源。**

> 设置一个 cname 指向 cdn 专用 DNS 服务器

1. 本地 DNS 会 指向 CDN 专用 DNS 服务器，用户输入 URL，经过本地 DNS 解析，DNS 系统会最终将域名的解析权交给 C CDN 专用 DNS 服务器

2. CDN 的 DNS 服务器将 CDN 的全局负载均衡系统的 IP 地址返回用户

3. 浏览器向 CDN 的全局负载均衡系统发起内容 URL 访问请求

4. CDN 全局负载均衡系统会返回距离用户最近的本地负载均衡系统的地址

5. 本地负载均衡系统会根据浏览器请求的资源和浏览器 IP 地址，选出合适的缓存服务器返回给浏览器

6. 浏览器重定向到缓存服务器，缓存服务器将用户所需内容响应给浏览器；

   > 如果没有缓存资源，就向源服务器请求，并缓存在本地

## async/await 原理

async/await 其实就是 generator 生成器的语法糖，可以说是官方实现的 co 库（自动执行 generator、yield）。生成器函数的返回值是一个 Generator，一个特殊的迭代器。`function* -> async` `function yield -> await`

```js
// request.js
function requestData(url) {
  // 异步请求的代码会被放入到executor中
  return new Promise((resolve, reject) => {
    // 模拟网络请求
    setTimeout(() => {
      // 拿到请求的结果
      resolve(url);
    }, 2000);
  });
}

// 需求:
// 1> url: 111 -> res: 111
// 2> url: res + "aaa" -> res: 111aaa
// 3> url: res + "bbb" => res: 111aaabbb

// 1.第一种方案: 多次回调
// 回调地狱
// requestData("111").then(res => {
//   requestData(res + "aaa").then(res => {
//     requestData(res + "bbb").then(res => {
//       console.log(res)
//     })
//   })
// })

// 2.第二种方案: Promise中then的返回值来解决
// requestData("111").then(res => {
//   return requestData(res + "aaa")
// }).then(res => {
//   return requestData(res + "bbb")
// }).then(res => {
//   console.log(res)
// })

// 3.第三种方案: Promise + generator实现
function* getData() {
  const res1 = yield requestData("111");
  const res2 = yield requestData(res1 + "aaa");
  const res3 = yield requestData(res2 + "bbb");
  const res4 = yield requestData(res3 + "ccc");
  console.log(res4);
}

// function* getDepartment() {
//   const user = yield requestData("id")
//   const department = yield requestData(user.departmentId)
// }

// 1> 手动执行生成器函数
// const generator = getData()
// generator.next().value.then(res => {
//   generator.next(res).value.then(res => {
//     generator.next(res).value.then(res => {
//       generator.next(res)
//     })
//   })
// })

// 2> 自己封装了一个自动执行的函数 -> 递归
// function execGenerator(genFn) {
//   const generator = genFn()
//   function exec(res) {
//     const result = generator.next(res)
//     if (result.done) {
//       return result.value
//     }
//     result.value.then(res => {
//       exec(res)
//     })
//   }
//   exec()
// }

// execGenerator(getData)
// execGenerator(getDepartment)

// 3> 第三方包co自动执行
// TJ: co/n(nvm)/commander/express/koa
// const co = require('co')
// co(getData)

// 4.第四种方案: async/await
async function getData() {
  const res1 = await requestData("111");
  const res2 = await requestData(res1 + "aaa");
  const res3 = await requestData(res2 + "bbb");
  const res4 = await requestData(res3 + "ccc");
  console.log(res4);
}

getData();
```

### 补充

迭代器就是实现了特定的 next 方法，并且返回具有 done、value 属性的对象。

可迭代对象是实现了迭代器接口协议的对象。在代码中我们使用 Symbol.iterator 访问该属性。for...of 可以遍历的东西必须是一个可迭代对象。

```js
// 创建一个迭代器对象来访问数组
const iterableObj = {
  names: ["abc", "cba", "nba"],
  [Symbol.iterator]: function () {
    let index = 0;
    return {
      next: () => {
        if (index < this.names.length) {
          return { done: false, value: this.names[index++] };
        } else {
          return { done: true, value: undefined };
        }
      },
    };
  },
};

// iterableObj对象就是一个可迭代对象
// 访问Symbol.iterator属性，得到迭代器函数 iterableObj[Symbol.iterator]
// console.log(iterableObj[Symbol.iterator])

// 1.第一次调用iterableObj[Symbol.iterator]函数
// const iterator = iterableObj[Symbol.iterator]()
// console.log(iterator.next()) // {done: false, value: 'abc'}
// console.log(iterator.next()) // {done: false, value: 'cba'}
// console.log(iterator.next()) // {done: false, value: 'nba'}
// console.log(iterator.next()) // {done: true, value: undefined}

// // 2.第二次调用iterableObj[Symbol.iterator]函数
// const iterator1 = iterableObj[Symbol.iterator]()
// console.log(iterator.next()) // {done: false, value: 'abc'}
// console.log(iterator.next()) // {done: false, value: 'cba'}
// console.log(iterator.next()) // {done: false, value: 'nba'}
// console.log(iterator.next()) // {done: true, value: undefined}

// 3.for...of可以遍历的东西必须是一个可迭代对象
// const obj = {
//   name: "why",
//   age: 18
// }

for (const item of iterableObj) {
  console.log(item); // abc cba nba
}
```

JS 原生的迭代器对象，String、Array、Map、Set、arguments 对象：

```js
const names = ["abc", "cba", "nba"];
console.log(names[Symbol.iterator]);

// 访问Symbol.iterator属性，得到迭代器函数，执行后返回迭代器（实现了next方法，并且返回值的对象具有 done、value属性）
const iterator1 = names[Symbol.iterator]();
console.log(iterator1.next());
console.log(iterator1.next());
console.log(iterator1.next());
console.log(iterator1.next());
```

## 网络安全

### XSS 跨站脚本攻击

XSS 就是代码注入，最简单的例子就是我们在 query 里拼接 script 脚本，拿到点击链接的那个人的 cookie 信息。

比如：`localhost:8080/?search=<script>alert(document.cookie)</script>`，只需要后端将 query 信息插进 html，就能自动执行脚本

```js
const http = require("http");
const url = require("url");

http
  .createServer(function (req, res) {
    const params = url.parse(req.url, true).query;
    console.log(params.search);
    res.write(`<html>Searching for <strong>${params.search}</strong></html>`);
    res.end();
  })
  .listen(8080, () => {
    console.log("服务器启动成功～");
  });
```

- 设置 cookie 为 HttpOnly，使客户端无法获取
- 过滤用户输入，字符转译

### CSRF 跨站请求伪造

比较经典的银行转账的例子。 A 访问了一个网站，网站有：

```
<img src="http://bank.com/ transfer?amount=100&to=C" />
```

当 A 访问该网站时，浏览器就会附带上 cookie 发出的转账请求。大多数情况下，该请求可能会失败，因为他要求 A 的认证信息。但是，如果 A 当时恰巧刚访问这个网站不久，他的浏览器与网站之间的 session 尚未过期，浏览器的 cookie 中含有 A 的认证信息。那么此时这个请求就会成功，钱将从用户 A 的账号转移到攻击者 C 的账号，而 A 对此毫不知情。

- CSRF Token，每次用户正常访问页面时，服务端随机生成返回给浏览器，都会携带不同的 CSRF Token，当用户从客户端得到了 Token，再次提交给服务器的时候，服务器需要判断 Token 的有效性
- 同源检测，利用请求头`Referer`字段，`Referer`字段会记录该`HTTP`请求的来源地址。对于`Ajax`请求，图片和`script`等资源请求，`Referer`为发起请求的页面地址。对于页面跳转，`Referer`为打开页面历史记录的前一个页面地址。因此我们使用`Referer`中链接的`Origin`部分可以得知请求的来源域名。
- 这个涉及到跨站的问题，同站是顶级域名和二级域名一致，需要看 SameSite 的值：
  - 1. Strict 浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。
  - 2. **Lax** 允许部分第三方请求携带 Cookie（表单就不可以携带 cookie 了）
  - 3. None 无论是否跨站都会发送 Cookie

### DOS、 DDOS 攻击原理和防范

DOS 攻击，它在短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问。DDOS 就是分布式的 DOS 攻击，表示攻击不是来自一个地方，而是来自四面八方，因此更难防。

DDOS 不是一种攻击，而是一大类攻击的总称。比如发送大量正常的请求，超出服务器的最大承受量，20 多个 IP 地址轮流发出请求，每个地址的请求量在每秒 200 次~300 次。

防范措施可以是服务器做过滤，以 nginx 为例：

```
location / {
  deny 1.2.3.4;
}
```

## ["1","2","3"].map(parseInt)

[1,NaN,NaN]

- https://www.cnblogs.com/Candybunny/p/5627905.html

## set 和 map 特点和区别

set 是集合，map 是字典

set 类似于数组，没有重复项，set 构造函数可以接受一个数组当参数，用来初始化：

```js
let arr1 = [1, 2, 3];
let arr2 = [3, 4, 5];
let s1 = new Set([...arr1, ...arr2]); //这样就把重复的3去掉了
console.log(s1); // {1, 2, 3, 4, 5}
```

map 键值对的集合，但是“键”的范围不限制于字符串，各种类型的值（包含对象）都可以当作键。Map 也可以接受一个数组作为参数，数组的成员是一个个表示键值对的数组。注意 Map 里面也不可以放重复的项.

```js
let map = new Map([["js", "react"]]);
console.log(map); // {'js' => 'react'}
map.set("js", "react"); //看看是否可以放重复的项
console.log(map); // {'js' => 'react'}
map.set("javaScript", "vue");
console.log(map); //Map {'js' => 'react','javaScript' => 'vue'} 不可以放重复项
```

## WeakSet WeakMap

### WeakSet

WeakSet 结构与 Set 类似，也是不重复的值的集合，但是和 Set 有两个区别：

- WeakSet 的成员只能是对象，而不能是其他类型的值
- WeakSet 中的对象都是弱引用，垃圾回收不会考虑 WeakSet 的引用，只要外部的引用消失，weakest 内部的引用就被清除了
  - 如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中
  - 相应的，WeakSet 对应的部分也不会存在了

```js
// 区别于正常引用
global.gc();
console.log(usageSize()); // ≈ 1.92M
function usageSize() {
  const used = process.memoryUsage().heapUsed;
  return Math.round((used / 1024 / 1024) * 100) / 100 + "M";
}

global.gc();
console.log(usageSize()); // ≈ 2.09M

let arr = new Array(10 * 1024 * 1024);

const map = new Map();
map.set(1, arr);
console.log(usageSize()); // ≈ 82.1M

arr = null;
global.gc();
console.log(usageSize()); // ≈ 82.09M

map.set(1, null);
global.gc();
console.log(usageSize()); // ≈ 2.09M
```

WeakSet 结构有以下三个方法。

WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。
WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。
WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。

```js
// 基本使用
const a = [
  [1, 2],
  [3, 4],
];
const ws = new WeakSet(a);
console.log(ws);
// WeakSet {[1, 2], [3, 4]}

// 弱引用
let obj = { age: 18 };
let ws = new WeakSet();
ws.add(obj); // WeakSet {{age: 18}}
obj = null;
ws.has(obj); // false
console.log(ws); // WeakSet {}
```

是有可能在浏览器控制台发现最后一行 console 打印出的结果仍旧是 ` WeakSet {{age: 18}}`。这是因为我们没办法控制浏览器的垃圾回收，之所以打印能出现内容，其实是因为打印的时候垃圾回收机制没有启动。如果你愿意，可以过一会再打印看看，结果就是`WeakSet {}`

当然我们也可以利用 node 来看一下内存，执行 `node --expose-gc weakset.js`：

```js
// weakset.js
function usageSize() {
  const used = process.memoryUsage().heapUsed;
  return Math.round((used / 1024 / 1024) * 100) / 100 + "M";
}

global.gc();
console.log(usageSize()); // ≈ 1.92M

let arr = new Array(10 * 1024 * 1024);
console.log(usageSize()); // ≈ 82.09M
const set = new WeakSet();
global.gc();
console.log(usageSize()); // ≈ 82.09M

set.add(arr);
global.gc();
console.log(usageSize()); // ≈ 82.09M

arr = null;
global.gc();
console.log(usageSize()); // ≈ 2.09M
```

可知 weakset.js 中定义的 arr 被清除后，其占用的堆内存被垃圾回收器成功回收了，只要外部的引用消失，weakest 内部的引用就被清除了。

### WeakMap

WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合，WeakMap 与 Map 的区别有两点：

- WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名
- WeakMap 的键名所指向的对象是弱引用，不计入垃圾回收机制

WeakMap.prototype.delete(key)：移除 key 的关联对象。执行后 WeakMap.prototype.has(key) 返回 false。
WeakMap.prototype.get(key)：返回 key 关联对象，或者 undefined（没有 key 关联对象时）。
WeakMap.prototype.has(key)：根据是否有 key 关联对象返回一个布尔值。
WeakMap.prototype.set(key, value)：在 WeakMap 中设置一组 key 关联对象，返回这个 WeakMap 对象。

注意，**WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。**

```js
const wm = new WeakMap();
let key = {};
let obj = { foo: 1 };
wm.set(key, obj);
obj = null;
wm.get(key);
// Object {foo: 1}
```

键值 obj 是正常引用。所以，即使在 WeakMap 外部消除了 obj 的引用，WeakMap 内部的引用依然存在。

## redux

redux 主要是由三部分组成：

- store：一个只读的单一数据源（存着组件的各种 state）
- action：对变化的描述
- reducer：对变化进行分发和处理

在整个过程中，数据流都是严格单向的：

![image](https://tva3.sinaimg.cn/large/006T9etDly1gzwypxero5j30ui0e8wi7.jpg)

如果想对数据进行修改，只有一种途径--派发 action。action 会被 reducer 读取，进而根据 action 内容的不同对数据进行修改，生成新的 state，新的 state 会更新到 store 对象里，进而驱动视图层面作出相应的改变。

- createStore 可以用来创建 store 对象
- store.dispatch 用来派发 action , action 会传递给 store
- reducer 接收 action,reducer 计算出新的状态并返回它 (store 负责调用 reducer)
- store.getState 这个方法可以帮助获取 store 里边所有的数据内容
- store.subscribe 方法可以让让我们订阅 store 的改变，只要 store 发生改变， store.subscribe 这个函数接收的这个回调函数就会被执行-

```js
import { createStore } from "redux";

// 1.初始化state
const initState = { counter: 0 };

// 2.reducer纯函数 不能修改传递的state。
// state处理逻辑：根据action的类型改变state -> return newState
function reducer(state = initState, action) {
  switch (action.type) {
    case "INCREMENT":
      return { ...state, counter: state.counter + 1 };
    case "ADD_COUNTER":
      return { ...state, counter: state.counter + action.num };
    default:
      return state;
  }
}

// 3. 基于 reducer 创建 store
const store = createStore(reducer);

// 4.action 通知reducer 让改变发生
const action1 = { type: "INCREMENT" };
const action2 = { type: "ADD_COUNTER", num: 2 };

// 5.订阅store的变化
store.subscribe(() => {
  console.log("state发生了改变: ", store.getState().counter);
});

// 6.派发action -> 会来到reducer的逻辑
store.dispatch(action1);
store.dispatch(action2);
```

## 一些手写

### new

首先说一下 new 做了什么事：

1. 新建一个对象
2. 将新对象的原型指向构造函数的原型对象
3. 改变构造函数的 this 指向
4. 判断返回值，如果上一步的构造函数返回一个对象，就返回这个对象；如果不是就返回新建的对象

```js
function objectFactory() {
  const obj = {};
  Constructor = [].shift.call(arguments);
  obj.__proto__ = Constructor.prototype;
  let ret = Constructor.apply(this, arguments);
  return typeof ret === "object" ? ret : obj;
}
```

### call apply bind

```js
function myCall(context, ...args) {
  const ctx = context || window;
  ctx.fn = this;
  var res = ctx.fn(...args);
  delete ctx.fn;
  return res;
}

function myApply(context, ...args) {
  const ctx = context || window;
  ctx.fn = this;
  var res = ctx.fn(args);
  delete ctx.fn;
  return res;
}

function myBind(context) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  var fbound = function () {
    var bindArgs = Array.prototype.call(arguments);
    return self.apply(
      this instanceof fbound ? this : context,
      args.concat(bindArgs)
    );
  };
  // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值
  fbound.prototype = this.prototype;
  return fbound;
}

// 直接将 fbound.prototype = this.prototype，直接修改 fbound.prototype 的时候，也会直接修改绑定函数的 prototype函数
// 所以需要一个空函数中转
function myBind(context) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  var fNOP = function () {};
  var fbound = function () {
    var bindArgs = Array.prototype.slice(arguments);
    return self.apply(
      this instanceof fNOP ? this : context,
      args.concat(bindArgs)
    );
  };
  fNOP.prototype = this.prototype;
  // 当获取 fbound.constructor 时，其实 fbound 中并没有 constructor 属性,当不能读取到 constructor 属性时，会从 fbound 的原型也就是 fbound.prototype 中读取，进一步在 FNOP.prototype 中读取，正好原型中有该属性，也就是 this
  fbound.prototype = new fNOP();
  return fbound;
}
```

![image](https://tvax3.sinaimg.cn/large/006T9etDly1h03u853f93j31hc0oq1kx.jpg)

- https://github.com/mqyqingfeng/Blog/issues/12

### 手写 instanceof

instanceof 就是判断是否是后代实例。instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，查找失败，返回 false。

```js
function isInstance(target, object) {
  while (target) {
    if (target.__proto__ === object.prototype) {
      return true;
    }
    target = target.__proto__;
  }
  return false;
}
```

### 手写 map

```js
Array.portotype.map2 = function (callback, thisArgs) {
  const arr = this;
  const mapArr = new Array(arr.length);
  let i = 0;
  while (i < arr.length) {
    if (i in arr) {
      mapArr = callback.call(thisArgs, arr[i], i, arr);
    }
    i++;
  }
  return mapArr;
};
```

### 手写 reduce

arr.reduce((res,cur, index, arr) => res+cur, 0)

- 参数： 一个回调函数，一个初始化参数 (非必须)
- 回调函数参数有 4 个值(res: 代表累加值，cur: 目前值，index: 第几个，arr 调用 reduce 的数组)
- 整体返回 res 累加值

```js
Array.prototype.reduce2 = function (callback, init) {
  var arr = this;
  let res;
  if (argument.length > 1) {
    res = init;
  } else {
    res = arr.splice(0, 1)[0];
  }
  for (let i = 0; i < arr.length; i++) {
    res = callback(res, arr[i], i, arr);
  }
  return res;
};
```

### Promise.resolve

Promsie.resolve(value) 可以将任何值转成值为 value 状态是 fulfilled 的 Promise，但如果传入的值本身是 Promise 则会原样返回它：

```js
Promsie.resolve = function (value) {
  if (value instanceof Promise) {
    return value;
  }
  return new Promsie((value) => {
    resolve(value);
  });
};
```

### Promise.reject

```js
Promise.reject = function (reason) {
  return new Promise((resolve, reject) => {
    reject(reason);
  });
};
```

### Promsie.all

- 传入的所有 Promsie 都是 fulfilled，则返回由他们的值组成的，状态为 fulfilled 的新 Promise；
- 只要有一个 Promise 是 rejected，则返回 rejected 状态的新 Promsie，且它的值是第一个 rejected 的 Promise 的值；
- 只要有一个 Promise 是 pending，则返回一个 pending 状态的新 Promise；

```js
Promise.all = function (promiseArr) {
  return new Promise((resolve, reject) => {
    const length = promiseArr.length;
    const result = [];
    let count = 0;
    if (length === 0) return resolve(result);
    for (let [i, p] of promiseArr.entries()) {
      Promise.resolve(p).then(
        (data) => {
          result[i] = data;
          count++;
          if (count === length) resolve(result);
        },
        (error) => {
          reject(error);
        }
      );
    }
  });
};
```

### Promise.allSettled

```js
Promise.allSettled = function (promiseArr) {
  return new Promise((resolve, reject) => {
    let count = 0;
    const result = [];
    const length = promiseArr;
    if (length === 0) {
      return resolve(result);
    }
    for (let [i, p] of promiseArr.entries()) {
      Promise.resolve(p).then(
        (data) => {
          result[i] = { status: "fullfilled", value: data };
          count++;
          if (count === length) resolve(result);
        },
        (err) => {
          result[i] = { status: "rejected", value: err };
          count++;
          if (count === length) resolve(result);
        }
      );
    }
  });
};
```

### Promise.race

Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝，取决于第一个完成的方式。

```js
Promise.race = function (promiseArr) {
  return new Promise((resolve, reject) => {
    for (let i of promiseArr) {
      Promise.resolve(i).then(
        (data) => {
          resolve(data);
        },
        (err) => {
          reject(err);
        }
      );
    }
  });
};
```

### Promise.any

all 的反向操作，有一个 resolve，就是 resolve，所有的 reject 了结果才是 rejected：

- 空数组或者所有 Promise 都是 rejected，则返回状态是 rejected 的新 Promsie，且值为 AggregateError 的错误；
- 只要有一个是 fulfilled 状态的，则返回第一个是 fulfilled 的新实例；
- 其他情况都会返回一个 pending 的新实例；

```js
Promise.any = function (promiseArr) {
  return new Promise((resolev, reject) => {
    let count = 0;
    const length = promiseArr.length;
    if (length === 0) return;
    for (let [i, p] of promiseArr.entries()) {
      Promise.resolve(p).then(
        (data) => {
          resolve(data);
        },
        (err) => {
          count++;
          if (count === length) {
            reject(new AggregateError("All promises were rejected"));
          }
        }
      );
    }
  });
};
```

## 防抖和节流

- 防抖常用于输入检索的场景
- 节流常用于鼠标频繁点击、滚动

防抖关心的是最后一次触发。

```js
// 每一次事件被触发，都会清除上一次的定时器，然后等待新的定时器
const debounce = function (fn, delay) {
  let timer = null;
  // 返回一个闭包，利用闭包保存timer确保不会被销毁，每一次点击会清理上一次的定时器
  return function () {
    let context = this;
    let args = arguments;
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(function () {
      // 若不改变this指向，则会指向fn的定义环境
      fn.call(context, ...args);
    }, delay);
  };
};
```

节流是指一段时间内只执行一次，关心的是第一次执行。

```js
const throtthle = function (fn, delay) {
  let timer = null;
  return function () {
    let context = this;
    let args = arguments;
    if (!timer) {
      timer = setTimeout(function () {
        fn.call(context, ...args);
        timer = null;
      }, delay);
    }
  };
};
```

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <input type="search" id="search" />
    <div id="showName"></div>
    <script>
      function debounce(fn, delay) {
        let timer = null;
        return function () {
          let context = this;
          let args = arguments;
          if (timer) {
            clearTimeout(timer);
          }
          timer = setTimeout(function () {
            fn.call(context, args);
          }, delay);
        };
      }
      let search = document.querySelector("#search");
      let showSearch = document.querySelector("#showName");
      function getSearchInfo(e) {
        showSearch.innerText = this.value;
        console.log(e);
        // showSearch.innerText = search.value;
      }
      // 是search在调用debounce返回的闭包函数
      search.onkeyup = debounce(getSearchInfo, 1000);
    </script>
  </body>
</html>
```

## 事件绑定 onclick 与事件监听 addEventListener

事件绑定：同一个对象，进行多次事件绑定，则后绑定的事件会覆盖之前绑定的事件，总之只能执行最后一个事件. -------- onclick

事件监听：同一个对象，进行多次事件监听，都会执行 -------addEventListener

## 数组转树

```js
// 从后端获取的包含相同结构的对象的数组数据
const entries = [
  {
    province: "浙江",
    city: "杭州",
    name: "西湖",
  },
  {
    province: "四川",
    city: "成都",
    name: "锦里",
  },
  {
    province: "四川",
    city: "成都",
    name: "方所",
  },
  {
    province: "四川",
    city: "阿坝",
    name: "九寨沟",
  },
];
// 描述数据层次关键字的数组
const level = ["province", "city", "name"];

// 格式化成如下的结构
[
  {
    value: "浙江",
    children: [
      {
        value: "杭州",
        children: [
          {
            value: "西湖",
            children: [],
          },
        ],
      },
    ],
  },
  {
    value: "四川",
    children: [
      {
        value: "成都",
        children: [
          {
            value: "锦里",
            children: [],
          },
          {
            value: "方所",
            children: [],
          },
        ],
      },
      {
        value: "阿坝",
        children: [
          {
            value: "九寨沟",
            children: [],
          },
        ],
      },
    ],
  },
];
```

题解：

```js
const formatEntries = (entries, level) => {
  const root = {
    value: "",
    children: [],
  };
  const map = {};
  const format = (entry, parent, index) => {
    if (!level[index]) {
      return;
    }
    if (map[entry[level[index]]]) {
      return format(entry, map[entry[level[index]]], index + 1);
    } else {
      const item = {
        value: entry[level[index]],
        children: [],
      };
      map[entry[level[index]]] = item;
      parent.children.push(item);
      return format(entry, item, index + 1);
    }
  };
  for (let i = 0; i < level.length; i++) {
    entries.forEach((entry) => {
      format(entry, root, i);
    });
  }
  return root.children;
};
console.log(formatEntries(entries, level));
```

## 稍微简单点的数组转树

```js
[
  {
    id: "01",
    name: "张大大",
    pid: "",
    job: "项目经理",
  },
  {
    id: "02",
    name: "小亮",
    pid: "01",
    job: "产品leader",
  },
  {
    id: "03",
    name: "小美",
    pid: "01",
    job: "UIleader",
  },
  {
    id: "04",
    name: "老马",
    pid: "01",
    job: "技术leader",
  },
  {
    id: "05",
    name: "老王",
    pid: "01",
    job: "测试leader",
  },
  {
    id: "06",
    name: "老李",
    pid: "01",
    job: "运维leader",
  },
  {
    id: "07",
    name: "小丽",
    pid: "02",
    job: "产品经理",
  },
  {
    id: "08",
    name: "大光",
    pid: "02",
    job: "产品经理",
  },
  {
    id: "09",
    name: "小高",
    pid: "03",
    job: "UI设计师",
  },
  {
    id: "10",
    name: "小刘",
    pid: "04",
    job: "前端工程师",
  },
  {
    id: "11",
    name: "小华",
    pid: "04",
    job: "后端工程师",
  },
  {
    id: "12",
    name: "小李",
    pid: "04",
    job: "后端工程师",
  },
  {
    id: "13",
    name: "小赵",
    pid: "05",
    job: "测试工程师",
  },
  {
    id: "14",
    name: "小强",
    pid: "05",
    job: "测试工程师",
  },
  {
    id: "15",
    name: "小涛",
    pid: "06",
    job: "运维工程师",
  },
];
```

题解：

```js
function arrayTotree(data) {
  const result = [];
  // 建立每个数组元素id和该对象的关系
  const map = {};
  for (const item of data) {
    // 一个新的带children的结构
    let newItem = (map[item.id] = {
      ...item,
      children: [],
    });
    // 找到data中每一项item的父节点
    let parent = map[item.pid];
    // 有父节点，把元素放在父亲的children下面
    if (parent) {
      parent.children.push(map[item.id]);
    } else {
      // 说明元素没有父节点，是根节点，把节点push到最终结果中
      result.push(newItem);
    }
  }
  return result;
}
```

## 树转数组

```js
const tree = [
  {
    id: "01",
    name: "张大大",
    pid: "",
    job: "项目经理",
    children: [
      {
        id: "02",
        name: "小亮",
        pid: "01",
        job: "产品leader",
        children: [
          {
            id: "07",
            name: "小丽",
            pid: "02",
            job: "产品经理",
            children: [],
          },
          {
            id: "08",
            name: "大光",
            pid: "02",
            job: "产品经理",
            children: [],
          },
        ],
      },
      {
        id: "03",
        name: "小美",
        pid: "01",
        job: "UIleader",
        children: [
          {
            id: "09",
            name: "小高",
            pid: "03",
            job: "UI设计师",
            children: [],
          },
        ],
      },
      {
        id: "04",
        name: "老马",
        pid: "01",
        job: "技术leader",
        children: [
          {
            id: "10",
            name: "小刘",
            pid: "04",
            job: "前端工程师",
            children: [],
          },
          {
            id: "11",
            name: "小华",
            pid: "04",
            job: "后端工程师",
            children: [],
          },
          {
            id: "12",
            name: "小李",
            pid: "04",
            job: "后端工程师",
            children: [],
          },
        ],
      },
      {
        id: "05",
        name: "老王",
        pid: "01",
        job: "测试leader",
        children: [
          {
            id: "13",
            name: "小赵",
            pid: "05",
            job: "测试工程师",
            children: [],
          },
          {
            id: "14",
            name: "小强",
            pid: "05",
            job: "测试工程师",
            children: [],
          },
        ],
      },
      {
        id: "06",
        name: "老李",
        pid: "01",
        job: "运维leader",
        children: [
          {
            id: "15",
            name: "小涛",
            pid: "06",
            job: "运维工程师",
            children: [],
          },
        ],
      },
    ],
  },
];
```

```js
function flatten(tree, arr = []) {
  tree.forEach((item) => {
    const { children, ...props } = item;
    // 添加除了children的属性
    arr.push(props);
    if (children) {
      // 递归将所有节点加入到结果集中
      flatten(children, arr);
    }
  });
  return arr;
}
console.log(flatten(tree, []));
```

## 移动 web 滚动性能优化

以滚动事件来说，滚动页面的时候，scroll 事件处理函数会一直触发，如果在事件处理函数里执行太多逻辑，代码会话费许多时间来执行，这就会导致页面卡顿。因为这里滚动本质上是 ui 线程来做的事，来执行事件处理函数是 js 线程的事，会相互阻塞，默认是事件处理函数的逻辑始终在 ui 线程执行滚动前调用。

我们可以利用 passive event：

```js
document.addEventListener(
  "scroll",
  (e) => {
    // 处理逻辑
  },
  { passive: true }
);
```

加了 passive 属性，浏览器不会再等待事件处理函数执行完毕再去进行滚动，而是页面先滚动完成，再执行事件处理逻辑。所以不会有事件绑定造成页面滚动卡顿。

## web 性能优化之：no-cache 与 must-revalidate 深入探究

cache-control 有一个指令是 no-cache，是指客户端会把带有 no-cache 的响应缓存下来，只不过每次不会直接用缓存，而是先去服务端验证才能使用（进行协商缓存验证）。

must-revalidate 也是 cache-control 的一个指令，是指对于一个过期缓存来说，必须先去服务端验证后才能使用（当然过期前，可以使用缓存）。

- [web 性能优化之：no-cache 与 must-revalidate 深入探究](https://segmentfault.com/a/1190000007317481)
- [可能是最被误用的 HTTP 响应头之一 Cache-Control: must-revalidate](https://zhuanlan.zhihu.com/p/60357719)

## Cache-Control 的 stale-while-revalidate 指令

revalidate 重新验证，stale 陈旧的。

max-age 就是 Cache-control 的一个指令，用于设置缓存存储的最大周期，超过这个时间缓存被认为过期（单位秒）。

stale-while-revalidate 会指定一个宽限期，就是说超过了 max-age，但是没超过 stale-while-revalidate 的话，还是可以使用过期缓存，同时会去请求新的缓存（返回 304）。超过了 stale-while-revalidate，会同步更新缓存。

所以 stale-while-revalidate 可以理解为**异步缓存更新**，比如 Cache-Control: max-age=60, stale-while-revalidate=3600 是说，这个缓存在 60 秒内是新鲜的，从 60 秒到 3660 秒的这一个小时内，虽然缓存是过期了，但仍可以直接使用这个过期缓存，同时进行异步 revalidate，在 3660 秒之后，就是完全过期了，需要进行传统的同步 revalidate。

![image](https://tva1.sinaimg.cn/large/006T9etDly1h09cpkv6lmj312809awg5.jpg)

在 stale-while-revalidate 指定的时间段内读取缓存的话，Chrome DevTools 里除了能看到本身的那个直接读取过期缓存的请求（200），还可以看到异步刷新缓存的请求（304）：

![image](https://tvax4.sinaimg.cn/large/006T9etDly1h09cqn0m1wj30ti0c4ajg.jpg)

过期的缓存在刷新之后就不再是过期缓存了，而是会重新开启一次全新的生命周期，stale-while-revalidate 指定的那个时间段并不是一定会经历完全：

![image](https://tva1.sinaimg.cn/large/006T9etDly1h09cxv8ar6j311y08swfr.jpg)

- [Cache-Control 的 stale-while-revalidate 指令](https://zhuanlan.zhihu.com/p/64694485)

## requestAnimationFrame

需要先说一下动画的原理。比如屏幕的刷新频率是 60HZ（图像的更新速度--屏幕上的图像每秒钟出现的次数），刷新频率为 60Hz 的屏幕每 16.7ms 刷新一次，我们在屏幕每次刷新前，将图像的位置向左移动一个像素，即 1px。这样一来，屏幕每次刷出来的图像位置都比前一个要差 1px，因此你会看到图像在移动。

而 setTimeout 其实就是通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的。不过这种动画通常会有卡顿，因为 setTimeout 的执行时机是不确定的，这取决于任务队列里的任务数量。可能会存在丢帧。

requestAnimationFrame 方法让我们可以在下一帧开始前调用指定函数，优势就是**由系统来决定回调函数的执行时机。**具体一点讲，如果屏幕刷新率是 60Hz,那么回调函数就每 16.7ms 被执行一次，如果刷新率是 75Hz，那么这个时间间隔就变成了 1000/75=13.3ms，换句话说就是，requestAnimationFrame 的步伐跟着系统的刷新步伐走。**它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次**，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。

```js
// 第一帧，若想在浏览器下一帧刷新前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()
// 回调函数执行一次的结果算一帧
window.requestAnimationFrame(render);
```

## requestIdleCallback

在帧之间的`Idle`（空闲）执行的回掉。**距离下一帧的刷新还有时间，就执行回调**。如果时间不够，就先下一帧再说。

由于 requestIdleCallback 利用的是帧的空闲时间, 所以有可能出现浏览器一直处于繁忙状态, 导致回调一直无法执行, 那这时候就需要在调用 requestIdleCallback 的时候传递第二个配置参数 timeout 了。 `timeout` 参数可以指定最长的等待时间，如果一直没时间执行这个逻辑，那么就算拖延了帧渲染也要执行。

```js
requestIdleCallback(myNonEssentialWork, { timeout: 2000 });

function myNonEssentialWork(deadline) {
  // 当回调函数是由于超时才得以执行的话，deadline.didTimeout为true
  while (
    // deadline.timeRemaining()可以获取到当前帧剩余时间
    (deadline.timeRemaining() > 0 || deadline.didTimeout) &&
    tasks.length > 0
  ) {
    doWorkIfNeeded();
  }
  if (tasks.length > 0) {
    requestIdleCallback(myNonEssentialWork);
  }
}
```

一帧包括了用户的交互, JavaScript 脚本执行；以及 requestAnimationFrame 的调用, 布局计算以及页面重绘等。

如果某一帧里执行的任务不多, 在不到 16.66ms(1000/60)内就完成了上述任务, 那么这一帧就会有一定空闲时间来执行 requestIdleCallback 的回调。

### react 中的 requestIdleCallback

react15 的架构的栈调和（diff 算法）是一个递归更新，本质上是树的深度优先的遍历。递归渲染 vdom 可能耗时很多，JS 计算量大了会阻塞渲染，会让用户觉得卡顿。

React16 polyfill 了 requestIdleCallback，就是 Scheduler，等到浏览器有空余时间，去执行 React 的异步更新任务。

React 16 之后引入了 fiber 架构（为了实现粒度更细的更新，也是为了可以打断），不是直接渲染 vdom 了，而是 vdom 先转成 fiber。vdom 里通过 children 关联父子节点，fiber 里通过 child 关联第一个子节点，然后通过 sibling 串联起子节点的下一个节点，子节点可以 return 到父节点。

vdom 树，变成了 fiber 链表。

每一个 fiber 都可以作为一个执行单元来处理，所以每一个 fiber 可以根据自身的优先级（lane ）来判断是否还有空间时间执行更新，如果没有时间更新，就要把主动权交给浏览器去渲染，做一些动画，重排（ reflow ），重绘 repaints 之类的事情，这样就能给用户感觉不是很卡。然后等浏览器空余时间，在通过 scheduler （调度器），再次恢复执行单元上来，这样就能本质上中断了渲染，提高了用户体验。

:::tip
react15 是对比新旧 Virtual DOM 来找出变化（patch），然后更新到实际的 DOM 中。

React 16 启用了全新的架构 Fiber，相应的 Diff 算法也有所改变

react16 的 diff 是对 oldFiber 和新的 ReactElement 节点的比对，将会生成新的 fiber 节点，同时标记上 effectTag，这些 fiber 会被连到 workInProgress 树中，作为新的 WIP 节点。树的结构因此被一点点地确定，而新的 workInProgress 节点也基本定型。在 diff 过后，workInProgress 节点的 beginWork 节点就完成了，接下来会进入 completeWork 阶段。
:::

## diff 算法

react 中 diff 算法主要遵循三个层级的策略：

- tree 层级：同层比较，只进行增加和删除操作，如果有跨层级的操作，react 会进行大量的删除与创建，影响性能，不推荐
- conponent 层级：同一个类的组件，会继续往下 diff，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的
- element 层级：对于比较同一层级的节点，每个节点在对应的层级用唯一的 key 作为标识，通过 key 值的对比，来判断子节点发生的操作，尽量减少节点的删除和创建操作

旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key：

- 若虚拟 DOM 中内容没变，直接使用之前的真实 DOM
- 若虚拟 DOM 中内容变了，则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM

旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key

- 根据数据创建新的真实 DOM，随后渲染到页面

不推荐使用 index 作为 key：

- 破坏顺序的操作，会产生没有必要的真实 DOM 更新 ，界面效果没问题，但效率低
- 对于包含输入类的 DOM，会产生错误 DOM 更新，界面有问题
- 仅用于渲染列表进行展示，使用 index 作为 key 是没有问题的

对于存在 input 的 ui 组件，如果用 index 作为 key，只看 key=0 的组件：

```js
// [a,b,c] =>
// input 输入的分别是 2 3 4
<li key="0">
  a <input type="text" />
</li>

// [c,b,a] =>
<li key="0">
  c <input type="text" />
</li>
```

这时候新老两个虚拟 dom 进行 diff，新老版的都有 key=0 的组件，react 认为同一个组件，则只可能更新组件；然后比较其 children，发现内容的文本内容不同（由 a--->c)，而 input 组件并没有变化，从而更新其子组件文本内容; input 组件不会更新，导致用户输入的值不会变化。

![key](https://tva1.sinaimg.cn/large/006T9etDly1h09jmn52uag30gn0axkjz.gif)

## 深拷贝浅拷贝

```js
// 普通版本
function clone(target) {
  if (typeof target === "object") {
    let cloneTarget = Array.isArray(target) ? [] : {};
    for (const key in target) {
      cloneTarget[key] = clone(target[key]);
    }
    return cloneTarget;
  } else {
    return target;
  }
}
```

- [深拷贝浅拷贝](https://juejin.cn/post/6844904197595332622)
- [如何写出一个惊艳面试官的深拷贝?](https://juejin.cn/post/6844903929705136141)

## localstorage、sessionstorage

Cookie 是 4k，Web Storage 为 5M

Web Storage 的存储对象是绑定域名，也就是说不同站点下的 Web 应用有着自己独立的存储对象，互相间是无法访问的，在这一点上 SessionStorage 和 LocalStorage 是相同的。

举个例子：部署在 abc.com 上的 Web 应用无法访问 xyz.com 的 Web Storage 存储对象。

同样，对于子域名也是一样，尽管www.grapecity.com.cn和gcdn.grapecity.com.cn 同属 grapecity.com.cn 主域下，但它们相互不能访问对方的存储对象。

另外，不仅对子域名相互独立，对于针对使用 http 和 https 协议间也是不同的

localStorage  中的键值对总是以**字符串**的形式存储，所以当我们需要把一个对象存在 localStorage 中时，只能用 JSON.stringify 将其转化成字符串存储，使用的时候用 JSON.parse 方法去取

```js
const userInfo = { user: "admin" };
localStorage.setItem("userInfo", JSON.stringify(userInfo));
JSON.parse(localStorage.getItem("userInfo"));
// {user: 'admin'}
```

### localStorage 与 sessionStorage 的区别

- 生命周期：sessionStorage 关闭窗口或标签页之后将会删除这些数据，localStorage 持久存储，除非手动删除
- 页面间共享
  - localStorage 存储的数据在同源（协议、域名、端口号一致）下的标签页之间可以共享；
  - sessionStorage 在刷新页面或进入同源另一页面，数据仍然存在；如果“独立”打开不同窗口，即使是同一页面，sessionStorage 对象也是不同的

## 科里化

科里化：将使用多个参数的一个函数转换成一系列使用一个参数的函数

```js
function add(a, b) {
  return a + b;
}

// 执行 add 函数，一次传入两个参数即可
add(1, 2); // 3

// 假设有一个 curry 函数可以做到柯里化
var addCurry = curry(add);
addCurry(1)(2); // 3
```

```js
const curry = function (fn, args) {
  const length = fn.length; // 获取fn形参的长度
  let _args = args || []; // 用来保存每次addCurry调用传入的实参，既然要保存肯定要形成闭包

  return function () {
    for (let i = 0; i < arguments.length; i++) {
      _args.push(arguments[i]);
    }
    // 当前执行获取到所有参数的长度，小于length，说明还要继续传参，这时我们返回 addCurry(fn, _args),便于下一次的括号调用
    if (_args.length < length) {
      return curry(fn, _args);
    } else {
      return fn(..._args);
    }
  };
};

const add = function (a, b, c) {
  return a + b + c;
};

const addCurry = curry(add);
addCurry(1)(2)(3);
```

## var、let、const

用 var 声明的变量会存在变量提升，为了加强对变量生命周期的控制，es6 引入了块级作用域：

- 函数内部
- 块中（`{}`）

此外当在全局作用域中使用 var 声明的时候，会创建一个新的全局变量作为全局对象的属性

let 和 const 属于块级声明，用于声明指定块的作用域之外无法访问的变量

let 和 const 的特点就是：

- 不存在变量提升
- 重复声明报错
- 存在暂时性死区（声明前不可用）

## 箭头函数

- 不存在 this，所以需要通过查找作用域链来确定 this 的值，最近一层非箭头函数的 this
- 没有 arguments 对象
- 不能通过 new 关键字调用，所以没有原型

## 模版字符串

```js
let str = "i am {{name}},age {{age}},job {{job}} ";
let data = {
  name: "xbd",
  age: 18,
  job: "CTO",
};
// 这里 match 是匹配的子串 {{name}} {{age}} {{job}}
// key 是 \w+
function templateFunc(str, data) {
  return str.replace(/\{\{(\w+)\}\}/g, function (match, key) {
    console.log(match, "match");
    return data[key];
  });
}
```

## TS 泛型

泛型就是类型参数化，通常用尖括号`<>`语法来定义函数的泛型参数。可以用来约束函数、类、接口。

### 约束函数参数的类型

约束函数参数的类型（可以给函数定义若干个被调用时才会传入明确类型的参数。）

比如：

```ts
function reflect<T>(params: T): T {
  return params;
}

// 用起来就是这样
const reflectStr = reflect<string>("string"); // str 类型是 string
const reflectNum = reflect<number>(1); // num 类型 number
```

泛型不仅可以约束函数整个参数的类型，还可以约束参数`key`、`value`的类型，比如参数的类型可以是数组、对象：

```ts
function reflect<T>(params: P[]) {
  return params;
}

// reflectArr 是 (string | number)[]
const reflectArr = reflect([1, "1"]);
```

最经典的还是`react`里的定义：

```js
function useState<S>(state: S, initialValue?: S) {
  return [state, (s: S) => void 0] as unknown as [S, (s: S) => void];
}
```

`return` 的结果的第一个元素的类型就是泛型 `S`，第二个函数的参数类型也是泛型 `S`。

### 泛型类

用泛型来约束类的属性和方法：

```ts
class MyType<S> {
  store: S;
  constructor(stores: S) {
    this.store = stores;
  }
  set(stores: S) {
    this.store = stores;
  }
  get() {
    return this.store;
  }
}

// 使用
const numMemory = new MyType<number>(1); // <number> 可缺省
const getNumMemory = numMemory.get(); // 类型是 number
numMemory.set(2); // 只能写入 number 类型
const strMemory = new MyType(""); // 缺省 <string>
const getStrMemory = strMemory.get(); // 类型是 string
strMemory.set("string"); // 只能写入 string 类型
```

### 泛型类型

类型本身就可以由泛型来定义：

```ts
// reflectFn 的类型是 <P>(param: P) => P
const reflectFn: <P>(param: P) => P = reflect;
```

> 这里我们为变量 reflectFn 显式添加了泛型类型注解，并将 reflect 函数作为值赋给了它。

这样就可以提出一个接口或者类型别名来描述这个类型：

```ts
type ReflectFuncton = <P>(param: P) => P;
interface IReflectFuncton {
  <P>(param: P): P;
}
const reflectFn2: ReflectFuncton = reflect;
const reflectFn3: IReflectFuncton = reflect;
```

进一步可以将泛型参数当作整个接口的一个参数，这样我们在用这个接口的时候就可以显示声明参数类型（比如： `Dictionary<string>而不只是Dictionary`），也可以知道接口里的其他成员的参数的类型了。

```ts
interface IGenericIdentityFn<T> {
  (arg: T): T;
}

function identity<T>(arg: T): T {
  return arg;
}

let myIdentity: IGenericIdentityFn<number> = identity;
```

注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 `GenericIdentityFn`的时候，还得传入一个类型参数来指定泛型类型（这里是：`number`），锁定了之后代码里使用的类型。

> 对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。

### 泛型约束

限定泛型的入参就是泛型约束。

- 泛型入参名 extends 类型
- 泛型入参名 extends 接口

```ts
// 限定泛型入参只能是 number | string | boolean 的子集
// 泛型入参名 extends 类型
function reflectSpecified<P extends number | string | boolean>(param: P): P {
  return param;
}
reflectSpecified("string"); // ok
reflectSpecified(1); // ok
reflectSpecified(true); // ok
reflectSpecified(null); // ts(2345) 'null' 不能赋予类型 'number | string | boolean'
```

也可以`泛型入参 extends 接口`

```ts
interface ILengthwise {
  length: number;
}

function loggingIdentity<T extends ILengthwise>(arg: T): T {
  console.log(arg.length); // Now we know it has a .length property, so no more error
  return arg;
}

// 现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：
loggingIdentity(3); // Error, number doesn't have a .length property

// 需要传入符合约束类型的值，必须包含必须的属性：
loggingIdentity({ length: 10, value: 3 });
```

## interface 和 type

- interface 接口：命名数据结构（例如对象）的另一种方式，仅限于对象
- type 类型别名：给一个类型起个新名字，类型别名不仅可以用来表示基本类型，还可以用来表示对象类型、联合类型、元组和交集

interface 会有 extends 这样的继承，type 也可以利用 联合类型 `&` 实现这种效果

- 类型别名可以继承接口，反之亦然。

interface 继承 interface

```ts
interface Person {
  name: string;
}

interface Student extends Person {
  stuNo: number;
}
```

interface 继承 type

```ts
type Person{
    name:string
}

interface Student extends Person {
  stuNo: number
}
```

type 继承 type

```ts
type Person{
    name:string
}

type Student = Person & { stuNo: number }
```

type 继承 interface

```ts
interface Person {
  name: string;
}

type Student = Person & { stuNo: number };
```

两者区别：

- type 可以定义基本类型别名、可以声明联合类型
- interface 重复声明会合并；而 type 重复声明会报错

类型别名 其实可涵盖 interface 的大部分场景。

对于 React 组件中 props 及 state，使用 type ，这样能够保证使用组件的地方不能随意在上面添加属性。如果有自定义需求，可通过 HOC 二次封装。

编写三方库时使用 interface，其更加灵活自动的类型合并可应对未知的复杂使用场景。

## 数组去重

### Map

```js
const arr = [1, 2, 2, 3, 4, 5, 5];
const deduplication = (arr) => {
  const map = new Map();
  arr.forEach((v, i) => {
    map.set(v, 1);
  });
  return [...map.keys()];
};
```

### Set

```js
const arr = [1, 2, 2, 3, 4, 5, 5];

const deduplication = (arr) => [...new Set(arr)];
```

### reduce

```js
const arr = [1, 2, 2, 3, 4, 5, 5];

const deduplication = (arr) =>
  arr.reduce((temp, v) => {
    return temp.includes(v) ? temp : [...temp, v];
  }, []);
```

### 对原数组进行操作

```js
const arr = [1, 2, 2, 3, 4, 5, 5];

const deduplication = (arr) => {
  const map = {};
  for (let i = 0; i < arr.length; i++) {
    if (map[arr[i]]) {
      arr.splice(i, 1);
      // 因为修改了原数组，arr.length也会改变，下一个数组元素会提前，所以需要 i-- 来让下一次的 i++ 命中提前的下一个数组元素
      i--;
    } else {
      map[arr[i]] = 1;
    }
  }
  return arr;
};
```

## 数组拍平

```js
// 迭代
function flat(arr) {
  while (arr.some((item) => Array.isArray(item))) {
    arr = [].concat(...arr);
  }
  return arr;
}

// 递归
function flatten(arr) {
  return arr.reduce((prev, cur) => {
    return prev.concat(Array.isArray(cur) ? flatten(cur) : cur);
  }, []);
}
```

## 几种数组遍历方法

1. forEach 和 map 能实现的功能相似
2. forEach、map、filter 都能实现对原数组的修改
3. forEach 没有返回值，map 有返回值，一个新数组（callback 的返回值是新数组的元素），filter 有返回值，一个新数组（callback 的返回值是新数组的元素）
4. for in 遍历 key，for of 遍历 value；
5. for of 不能遍历普通的对象，需要和 Object.keys()搭配使用。

> map 方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值

## promise 请求超时处理

```js
function timeoutPromise(time) {
  const delay = new Promise((resolve, reject) => {
    setTimeout(function () {
      reject("timeout");
    }, time);
  });
  const request = new Promise((resolve, reject) => {
    fetch("https://api.github.com/users/octocat")
      .then((data) => {
        resolve(data);
      })
      .catch((err) => {
        reject(err);
      });
  });
  return Promise.race([delay, request]);
}

timeoutPromise(100)
  .then((data) => {
    console.log(data);
  })
  .catch((err) => {
    console.log(err);
  });
```

## Promise.retry

实现 Promise.retry，成功后 resolve 结果，失败后重试，尝试超过一定次数才真正的 reject

```js
Promise.retry = function (promiseFn, times = 3) {
  return new Promise(async (resolve, reject) => {
    while (times--) {
      // console.log("times");
      try {
        var ret = await promiseFn();
        resolve(ret);
        break;
      } catch (error) {
        if (!times) reject(error);
      }
    }
  });
};
function getProm() {
  const n = Math.random();
  return new Promise((resolve, reject) => {
    setTimeout(() => (n > 0.9 ? resolve(n) : reject(n)), 1000);
  });
}
Promise.retry(getProm);
```

## rem

等比布局，rem 作用于非根元素时，相对于根元素字体大小；rem 作用于根元素字体大小时，相对于其出初始字体大小

rem 取值分为两种情况，设置在根元素时和非根元素时，举个例子

```css
/* 作用于根元素，相对于原始大小（16px），所以 html 的 font-size 为 32px */
html {
  font-size: 2rem;
}
/* 作用于非根元素，相对于根元素字体大小，所以为 64px  */
p {
  font-size: 2rem;
}
```

使用 rem 布局，根据不同的屏幕设置不同的 fontSize

```js
var docEl = document.documentElement;
var width = docEl.clientWidth;
if (width >= 414) {
  docEl.style.fontSize = "16px";
} else {
  docEl.style.fontSize = width / 414 + "px";
}
```

## 排序算法

先来看一下 JS 中自带的排序：

```js
arr.sort(compareFunction);
```

默认排序顺序是在将元素转换为字符串，然后比较字符串 UniCode 码的顺序

- 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；
- 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变；
- 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前；

```js
// 升序排列
arr.sort((a, b) => {
  return a - b;
});
```

sort 的时间复杂度，以 chrome 为例，Chrome 对 sort 做了特殊处理：

- 在 v8 7.0 前，对于长度 <= 10 的数组使用的是插入排序 ，>10 的数组使用的是快速排序
- 在 v8 7.0 后，混合排序 timSort：插入排序+归并排序，主要考虑到快排是不稳定的，最坏的情况是 O(n^2)。

timSort：在数据量小的**子数组中使用插入排序，然后再使用归并排序将有序的子数组进行合并排序**，时间复杂度为 O(nlogn)。

> 对于已经排序好的数组，会以 O(n) 的时间内完成排序，因为这样的数组将只产生单个 run ，不需要合并操作。最坏的情况是 O(nlogn)

```js
// 合并两个有序小数组 left、right 到 result
function merge(left, right) {
  let result = [],
    ileft = 0,
    iright = 0;
  while (ileft < left.length && iright < right.length) {
    if (left[ileft] < right[iright]) {
      result.push(left[ileft++]);
    } else {
      result.push(right[iright++]);
    }
  }
  while (ileft < left.length) {
    result.push(left[ileft++]);
  }
  while (iright < right.length) {
    result.push(right[iright++]);
  }
  return result;
}

// 插入排序
function insertionSort(arr) {
  let n = arr.length;
  let preIndex, current;
  for (let i = 1; i < n; i++) {
    preIndex = i - 1;
    current = arr[i];
    while (preIndex >= 0 && arr[preIndex] > current) {
      arr[preIndex + 1] = arr[preIndex];
      preIndex--;
    }
    arr[preIndex + 1] = current;
  }
  return arr;
}

// timsort
function timsort(arr) {
  // 空数组或数组长度小于 2，直接返回
  if (!arr || arr.length < 2) return arr;
  let runs = [],
    sortedRuns = [],
    newRun = [arr[0]],
    length = arr.length;
  // 划分 run 区，并存储到 runs 中，这里简单的按照升序划分，没有考虑降序的run
  for (let i = 1; i < length; i++) {
    // 这里按照升序划分，如果当前值比前一个小，把 run 区放进 runs，并且把当前值放到新的 run 区
    if (arr[i] < arr[i - 1]) {
      runs.push(newRun);
      newRun = [arr[i]];
    } else {
      // 否则当前值放到当前 run 区
      newRun.push(arr[i]);
    }
    // 处理最后一个 run 区
    if (length - 1 === i) {
      runs.push(newRun);
      break;
    }
  }
  // 由于仅仅是升序的run，没有涉及到run的扩充和降序的run，因此，其实这里没有必要使用 insertionSort 来进行 run 自身的排序
  // 这里的 run 区其实是有序的
  for (let run of runs) {
    insertionSort(run);
  }
  // 合并 runs
  sortedRuns = [];
  for (let run of runs) {
    sortedRuns = merge(sortedRuns, run);
  }
  return sortedRuns;
}

// 测试
var numbers = [4, 2, 5, 1, 3];
timsort(numbers);
// [1, 2, 3, 4, 5]
```

:::tip
常用的时间复杂度所耗费的时间从小到大依次是

O(1) < O(logn) < O(n) < O(nlogn) < O(n²) < O(n³) < O(2^n) < O(n!) < O(n^n)
:::

### 冒泡排序

冒泡排序的核心就是**重复比较相邻的两项**。如果第一项比第二项大，则交换两者位置。

每一轮操作，都会将这一轮中最大的元素放置到数组的末尾。每一轮操作，都会将这一轮中最大的元素放置到数组的末尾。假如数组的长度是 n，那么当我们重复完 n 轮的时候，整个数组就有序了。

不过需要注意的是，随着外层循环的进行，数组尾部的元素会渐渐变得有序——第 1 轮循环结束，最大的元素就到了数组末尾；第 2 轮循环结束，数组的最后两位是有序的——第 n 轮循环结束，数组最后 n 个元素是有序的（需要注意内层循环的次数）。

```js
function bubbleSort(arr) {
  const len = arr.length;
  // 外层循环控制 比较+交换 一共多少轮
  for (let i = 0; i < len; i++) {
    // 内层循环控制每一轮遍历的 比较+交换
    for (let j = 0; j < len - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}
```

时间复杂度：O(n^2)

### 选择排序

选择排序的核心是找最小值：每次找出当前范围的最小值，放到当前范围的头部，缩小范围，继续找最小值放到头部，重复以上操作，直到数组有序。

```js
function selectSort(arr) {
  const len = arr.length;
  let minIndex;
  for (let i = 0; i < len - 1; i++) {
    // i 为当前范围左边界
    minIndex = i;
    // j 为当前范围的右边界
    for (let j = i; j < len; j++) {
      // 若 j 处的值小于当前最小值，更新最小值的索引
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    // 将最小值放到当前区间的头部
    if (minIndex != i) {
      [arr[i], arr[minIndex]] = [arr[minndex], arr[i]];
    }
  }
  return arr;
}
```

时间复杂度：O(n^2)

### 插入排序

插入排序的核心是找到当前元素在前面的有序序列中的位置。

```js
function insertSort(arr) {
  const len = arr.length;
  let temp;
  // 外层循环对应当前元素
  for (let i = 1; i < len; i++) {
    // 辅助待插入元素找到索引
    let j = i;
    // temp 用于保存待插入元素
    temp = arr[i];
    // 内层循环对应前面的有序序列
    // 判断 j 前面的元素是否大于 temp
    while (j > 0 && arr[j - 1] > temp) {
      // j 前面的一个元素后移一位，为 temp 让出位置
      arr[j] = arr[j - 1];
      j--;
    }
    // 循环让位，得到正确索引
    arr[j] = temp;
  }
  return arr;
}
```

时间复杂度：O(n^2)

### 归并排序

归并排序的核心是**分割+合并**，将大数组反复分割为一个一个的原子项，合并是将原子项反复地组装回原有的大数组。

```js
function mergeSort(arr) {
  const len = arr.length;
  // 处理边界情况
  if (len <= 1) {
    return arr;
  }
  // 计算分割点
  const mid = Math.floor(len / 2);
  // 递归分割左子数组，然后合并为有序数组
  const leftArr = mergeSort(arr.slice(0, mid));
  // 递归分割右子数组，然后合并为有序数组
  const rightArr = mergeSort(arr.slice(mid, len));
  // 合并左右两个有序数组
  arr = mergeArr(leftArr, rightArr);
  // 返回合并后的结果
  return arr;
}

// 合并两个有序数组
function mergeArr(arr1, arr2) {
  // 初始化两个指针，分别指向 arr1 和 arr2
  let i = 0,
    j = 0;
  // 初始化结果数组
  const res = [];
  // 缓存arr1的长度
  const len1 = arr1.length;
  // 缓存arr2的长度
  const len2 = arr2.length;
  // 合并两个子数组
  while (i < len1 && j < len2) {
    if (arr1[i] < arr2[j]) {
      res.push(arr1[i]);
      i++;
    } else {
      res.push(arr2[j]);
      j++;
    }
  }
  // 若其中一个子数组首先被合并完全，则直接拼接另一个子数组的剩余部分
  if (i < len1) {
    return res.concat(arr1.slice(i));
  } else {
    return res.concat(arr2.slice(j));
  }
}
```

归并排序的时间复杂度是 O(nlog(n))

### 快速排序

快速排序的核心是**通过基准值进行分区**，小于基准值的都在左边，大于基准值的都在右边，针对基准的左右侧分别利用新的基准值再次进行分区，直到对数组完成排序。

```js
// 分区
function partition(arr, start, end) {
  // 以最后一个元素为基准
  const pivotValue = arr[end];
  // pivotIndex 就是最终基准元素的索引
  let pivotIndex = start;
  for (let i = start; i < end; i++) {
    // 没发生交换说明 pivotIndex 对应的值比基准值大，这时候 pivotIndex 不变
    // 等到下一个小于基准值的元素（索引为 i），再来交换 i 与 pivotIndex 的值
    // 这时候大的值就到了 i 处，pivotIndex 加 1，pivotIndex 左边的值就都是小于基准值的
    if (arr[i] < pivotValue) {
      [arr[i], arr[pivotIndex]] = [arr[pivotIndex], arr[i]];
      pivotIndex++;
    }
  }
  // 把基准值挪到基准位置
  [arr[pivotIndex], arr[end]] = [arr[end], arr[pivotIndex]];
  return pivotIndex;
}

function quickSort(arr, start, end) {
  if (start >= end) return;
  let pivotIndex = partition(arr, start, end);
  quickSort(arr, start, pivotIndex - 1);
  quickSort(arr, pivotIndex + 1, end);
  return arr;
}
```

```js
let arr = [7, -2, 4, 1, 6, 5, 0, -4, 2];
quickSort(arr, 0, array.length - 1);
```

时间复杂度：O(nlog(n))

## SameSite 以及 SameParty

### SameSite

SameSite 是 Cookie 的一个属性，chrome80 版本之后默认屏蔽了第三方的 Cookie（默认值从 None-> Lax）。

SameSite 属性的意义就是，该属性可以让 Cookie 在跨站请求时不会被发送，阻止跨站请求伪造攻击（CSRF）。

SameSite 是涉及到**同站/跨站**的概念，这里的同站指的是，**两个 URL 的 eTLD+1（有效顶级域名+二级域名） 相同**，eTLD 表示有效顶级域名，注册于 Mozilla 维护的公共后缀列表（Public Suffix List）中，例如，`.com`、`.co.uk`、`.github.io` 等。eTLD+1 则表示，有效顶级域名+二级域名，例如 `taobao.com` 等。

SameSite 分成第一方、第三方。在 chrome 80 版本前，Cookie 的发送关心的是目的域，而不看来源，也就是所谓的 “不认来源，只看目的”，Cookie 只看 domain 和 path，这里的 domain 指的是请求的域名，可以看这个例子：

通过响应头在浏览器中设置了一个 cookie，domain 是.a.com：

```
set-cookie: id=main; domain=.a.com;
```

1. 网页`www.b.com/index.html`的前端页面，去请求接口`www.a.com/api`
2. 网页`www.a.com/index.html`的前端页面，去请求接口`www.a.com/api`

这两个都会带上我们刚刚设置的 cookie，因为“不认来源，只看目的”。可以进一步细分，1 属于第三方 cookie，2 属于第一方 cookie。

不过在后来，chrome 将 `SameSite:Lax` 设置为默认属性，现在变成：**既看来源，又看目的**

1. Strict 代表完全禁止三方 Cookie，这是最严格防护，可以避免被 CSRF 攻击，但缺点也很明显，像天猫、淘宝这种同属一个主体运营的网站不得不重复登录
2. None 代表完全不做限制，即之前 "不认来源，只看目的" 的 Cookie 取用原则
3. Lax 则是折中，**既看来源，又看目的**，在某些情况下会限制三方 Cookie 的携带，某些情况又放行，这也是浏览器的默认值（包括 safari）

![image](https://tva1.sinaimg.cn/mw690/006T9etDly1h1rwq7ulhmj315g0f611s.jpg)

也就是说 Post 表单，iframe，AJAX，Image 这四种情况从以前的跨站会发送三方 Cookie，变成了不发送

- Post 表单：应该的，学 CSRF 总会举表单的例子
- iframe：iframe 嵌入的 web 应用有很多是跨站的，都会受到影响
- AJAX：可能会影响部分前端取值的行为和结果
- Image：图片一般放 CDN，大部分情况不需要 Cookie，故影响有限。但如果引用了需要鉴权的图片，可能会受到影响

### SameParty

SameParty 可以理解为**站点联合**，集合里的站点设置的 Cookie 在集合内部，都会被当作第一方 Cookie，也就是说**集合中的域名都会被当作一个站对待**。

SameParty 可以把`.taobao.com`、`.tmall.com`和`.alimama.com`三个站合起来，它们设置的 Cookie 在这个集合内部不会被当作第三方 Cookie 对待。

首先需要定义 FirstParty 集合：在`.taobao.com`、`.tmall.com` 和`.alimama.com` 三个站的服务器下都加一个配置文件，放在`/.well-know/`目录下，命名为 `first-party-set`。

其中一个是 “组长”，暂定为`.taobao.com`，在它的的服务器下写入

```json
// /.well-know/first-party-set
{
  "owner": ".taobao.com"
}
```

另外两个是组员：

```json
// /.well-know/first-party-set
{
  "owner": ".taobao.com",
  "members": [".tmall.com", ".alimama.com"]
}
```

并且，在下发 Cookie 时，需要注明 SameParty 属性：

```
Set-Cookie: id=nian; SameParty; Secure; SameSite=Lax; domain=.taobao.com
```

这样，我们打开`.tmall.com` 的网站，向`.taobao.com` 发起 AJAX 请求，都会带上这个 Cookie，即使当前的 SameSite 属性是 Lax，因为这**集合中的三个域名都会被当作一个站对待**，也就是说，在浏览器眼中，这个 Cookie 现在就是第一方 Cookie。

而不在集合中的 `baidu.com` 发起的 AJAX 请求则不会带上。

需要注意的是，使用 SameParty 属性时，必须要同时使用 https(secure 属性)，并且 SameSite 不能是 Strict。
