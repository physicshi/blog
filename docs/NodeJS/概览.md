---
sidebar_position: 1
---

服务端和前端的思考方式是非常不同的，比如对于服务端来讲：

- 服务的稳定性
  - 服务端可能会遭到各种恶意攻击和误操作
  - 单个客户端可以意外挂掉，但是服务端不行（需要进程守护）
- cpu 和内存（优化和扩展）
  - 服务端需要承载许多请求，cpu 和内存都是稀缺资源
  - stream 写日志，redis 存 session
- 安全
  - 越权操作、数据库攻击
- 日志记录
  - 通常来讲前端只是日志的发起方
  - 服务端需要记录日志、存储日志、分析日志
- 集群和服务拆分
  - 扩展机器、服务拆分承载大流量

## nodejs 处理 http 请求

- get 请求和 querystring
- post 请求和 postdata
- 路由

### get 请求和 querystring

- get 请求客户端向 server 端获取数据
- 通过 querystring 来传递数据（url 参数：html?a=123&b=1000）

```js
// demo
const http = require("http");
const querystring = require("querystring");

const server = http.createServer((req, res) => {
  // 获取完整请求的 url
  const url = req.url;
  // 浏览器直接访问就是get请求
  const method = req.method;
  // url参数，解析成对象
  const query = querystring.parse(url.split("?")[1]);
  const quertJSON = JSON.stringify(query);

  res.setHeader("Content-Type", "text/html; charset=utf-8");
  res.write(`<h1>${method}</h1>`);
  // 写入字符串（客户端默认接受到的是字符串）或者传入 buffer
  res.write(`<p>queryJSON: ${quertJSON}</p>`);
  // 关闭流
  res.end();
});

server.listen(8000, () => {
  console.log("server is running");
});
```

![get_url.png](http://tva1.sinaimg.cn/large/006T9etDly1gz7e0bvvftj30ni0auabn.jpg)

#### 返回头部信息主要有两种方式

- res.setHeader：一次写入一个头部信息
- res.writeHeader：同时写入 header 和 status

```js
res.setHeader("content-type", "application/json");

res.writeHeader(200, {
  "content-type": "application/json",
});
```

#### 请求头/响应头 Content-Type 用于向接收方说明传输资源的类型

对于 GET 请求，需要传递的数据比较简单，我们通常使用 QueryString 的方式传递，例如 `https://test.com/api?a=1&b=2`，那么 Content-Type 的值就不是那么重要了。对于 POST 请求，Content-Type 的值就非常重要了，需要根据不同场景做不同选择。

- application/x-www-form-urlencoded

直接用 form 表单提交数据就是这种，它和 querystring 的方式的区别只是放在了 body 里，并且按规则编码：

1. 空格转换为 “+” 号；非字母数字的其它字符转换为类似于“%E0”的两位 16 进制表示的 ASCII 码；
2. 换行符被转换为“CR LF”；

```html
<form action="https://example.com/" method="post">
  <input type="text" name="name" value="张三" />
  <input type="text" name="age" value="18" />
  <button type="submit">Submit</button>
</form>
```

![form_post.png](http://tva1.sinaimg.cn/large/006T9etDly1gz9zy1r2ezj30ni0acdkh.jpg)

通过 & 分隔的 form-urlencoded 的方式需要对内容做 url encode，如果传递大量的数据，比如上传文件的时候就不是很合适了，因为文件 encode 一遍的话太慢了，这时候就可以用 form-data

- multipart/form-data

form data 不再是通过 & 分隔数据，而是用 --------- + 一串数字做为分隔符。

![post_formdata.png](http://tva1.sinaimg.cn/large/006T9etDly1gza08vxedkj31260gytj5.jpg)

form-data 需要指定 content type 为 multipart/form-data，然后指定 boundary 也就是分割线。

body 里面就是用 boundary 分割线分割的内容。

这种方式适合传输文件，而且可以传输多个文件。但是毕竟多了一些只是用来分隔的 boundary，所以请求体会增大。

- application/json

form-urlencoded 需要对内容做 url encode，而 form data 则需要加很长的 boundary，两种方式都有一些缺点。如果只是传输 json 数据的话，不需要用这两种，只需要指定 content type 为 application/json 就行

![post_json.png](http://tva1.sinaimg.cn/large/006T9etDly1gza0bpmnoaj30ni0dk0xp.jpg)

#### buffer

JavaScript 可以直接去处理非常直观的数据，比如字符串，再展示给用户，对于图片我们都是拿到图片的 url 地址，然后交给浏览器去获取这个图片，然后浏览器进行渲染。

服务端处理本地文件比较多，会涉及到读取二进制数据再进行转换（直接操作二进制数据），比如我们需要读取的是一张图片数据（二进制），再通过某些手段对图片数据进行二次的处理(裁剪、格式转换、旋转、添加滤 镜)，Node 中有一个 Sharp 的库，就是读取图片或者传入图片的 Buffer 对其再进行处理；比如在 Node 中通过 TCP 建立长连接，TCP 传输的是字节流，我们需要将数据转成字节再进行传入，并且需要知道传输字节的大小。

Node 提供了一个全局的类，Buffer，Buffer 中存储的是二进制数据，可以将 Buffer 看成是一个存储二进制的数组：这个数组中的每一项，可以保存 8 位二进制：00000000。

```js
const buffer = new Buffer("hello");
console.log(buffer); // <Buffer 68 65 6c 6c 6f>
// 更常见的创建方式
const buffer1 = Buffer.from("hello");
console.log(buffer1); // <Buffer 68 65 6c 6c 6f>
// 中文 默认utf8，一个中文对应3个字节
const buffer2 = Buffer.from("你好啊");
console.log(buffer2); // <Buffer e4 bd a0 e5 a5 bd e5 95 8a>
// utf16le，一个中文对应两个字节
const buffer3 = Buffer.from("你好啊", "utf16le");
console.log(buffer3); // <Buffer 60 4f 7d 59 4a 55>

// 对中文进行编码：utf8
const buffer4 = Buffer.from("你好啊");
consol.log(buffer4); // <Buffer e4 bd a0 e5 a5 bd e5 95 8a>
// 对中文进行解码：utf8
console.log(buffer4.toString("utf8")); // 你好啊
```

Buffer 数组的每一位都是一个字节，8 个 bit：

- 二进制 1111 1111
- 十进制 0 ～ 15 0 ～ 15
- 16 进制 0 ～ f 0~f

所以打印出来的实际上是 16 进制的形式，存储到 Buffer 的时候是二进制。

### post 请求和 postdata

- post 请求，客户端向服务端传递数据
- 通过 post data

```js
const http = require("http");

const server = http.createServer((req, res) => {
  if (req.method === "POST") {
    console.log("req content-type:", req.headers["content-type"]);
    let postData = "";
    req.on("data", (chunk) => {
      postData += chunk.toString();
    });
    req.on("end", () => {
      console.log("postData:", postData);
      res.end("ok");
    });
  }
});

server.listen(8000, () => {
  console.log("server is running");
});
```

利用 postman：

```
req content-type: application/json
postData: {
    "name":"zhangsna",
    "age": 18
}
```

```js
const http = require("http");
const querystring = require("querystring");

const server = http.createServer((req, res) => {
  const method = req.method;
  const url = req.url;
  const query = querystring.parse(url.split("?")[1]);
  const path = url.split("?")[0];
  // 设置返回格式JSON
  res.setHeader("Content-Type", "application/json");
  const resData = {
    method,
    url,
    query,
    path,
  };

  if (method === "GET") {
    res.end(JSON.stringify(resData));
  }
  if (method === "POST") {
    let postData = "";
    req.on("data", (chunk) => {
      postData += chunk.toString();
    });
    req.on("end", () => {
      resData.postData = postData;
      res.end(JSON.stringify(resData));
    });
  }
});

server.listen(8000, () => {
  console.log("server is running");
});
```

但是直接用内置的 http 模块去做服务端开发会有一些弊端：

- 需要写很多底层代码——例如手动指定 HTTP 状态码和头部字段，最终返回内容。如果我们需要开发更复杂的功能，涉及到多种状态码和头部信息（例如用户鉴权），这样的手动管理模式非常不方便

- 没有专门的路由机制——路由是服务器最重要的功能之一，通过路由才能根据客户端的不同请求 URL 及 HTTP 方法来返回相应内容。但是上面这段代码只能在 http.createServer 的回调函数中通过判断请求 req 的内容才能实现路由功能，搭建大型应用时力不从心

## express

```shell
npm install express
```

```js
const express = require("express");

// express其实是一个函数: createApplication
// 返回app
const app = express();

// 监听默认路径
app.get("/", (req, res, next) => {
  res.end("Hello Express");
});

app.post("/", (req, res, next) => {});

app.post("/login", (req, res, next) => {
  res.end("Welcome Back~");
});

// 开启监听
app.listen(8000, () => {
  console.log("express服务器启动成功");
});
```

### 中间件

express 的核心就是中间件（回调函数）。

express 主要提供了两种方式注册中间件：app/router.use 和 app/router.methods

```js
const express = require("express");

const app = express();

// 编写普通的中间件
// use注册一个中间件(回调函数)
app.use((req, res, next) => {
  console.log("注册了第01个普通的中间件~");
  next();
});

app.use((req, res, next) => {
  console.log("注册了第02个普通的中间件~");
  next();
});

app.use((req, res, next) => {
  console.log("注册了第03个普通的中间件~");
  res.end("Hello Middleware");
});

app.listen(8000, () => {
  console.log("普通中间件服务器启动成功~");
});
```

```
普通中间件服务器启动成功~
注册了第 01 个普通的中间件~
注册了第 02 个普通的中间件~
注册了第 03 个普通的中间件~
```

```js
const express = require("express");

const app = express();

app.use((req, res, next) => {
  console.log("common middleware01");
  next();
});

// 路径匹配的中间件
app.use("/home", (req, res, next) => {
  console.log("home middleware 01");
});

// 中间插入了一个普通的中间件
app.use((req, res, next) => {
  console.log("common middleware02");
  next();
});

app.use("/home", (req, res, next) => {
  console.log("home middleware 02");
});

app.listen(8000, () => {
  console.log("express初体验服务器启动成功~");
});
```

直接访问 8000

```
common middleware01
common middleware02
```

访问 8000/home

```
common middleware01
home middleware 01
```

### 路由

```js
const express = require("express");
const userRouter = require("./routers/users");
const productRouter = require("./routers/products");

const app = express();

app.use("/users", userRouter);
app.use("/products", productRouter);

app.listen(8000, () => {
  console.log("路由服务器启动成功~");
});

// ./routers/users.js
/**
 * 举个例子:
 *   请求所有的用户信息: get /users
 *   请求所有的某个用户信息: get /users/:id
 *   请求所有的某个用户信息: post /users body {username: passwod:}
 *   请求所有的某个用户信息: delete /users/:id
 *   请求所有的某个用户信息: patch /users/:id {nickname: }
 */

const express = require("express");

const router = express.Router();

router.get("/", (req, res, next) => {
  res.json(["cba", "abc", "nba"]);
});

router.get("/:id", (req, res, next) => {
  res.json(`${req.params.id}用户的信息`);
});

router.post("/", (req, res, next) => {
  res.json("create user success~");
});

module.exports = router;

// ./routers/products
const express = require("express");

const router = express.Router();

router.get("/", (req, res, next) => {
  res.json(["123", "321", "231"]);
});

module.exports = router;
```

### 参数解析

```js
const express = require("express");

const app = express();

app.get("/products/:id/:name", (req, res, next) => {
  console.log(req.params); // { id: '1', name: 'zhangsan' }
  // req.params => 在数据库中查询真实的商品数据
  res.end("商品的详情数据~");
});

app.get("/login", (req, res, next) => {
  console.log(req.query); // { name: 'zhangsan', age: '18' }
  res.end("用户登录成功~");
});

app.listen(8000, () => {
  console.log("普通中间件服务器启动成功~");
});
```

### 响应数据

- end 方法
  - 类似于 http 中的 response.end 方法，用法是一致的
- json 方法
  - json 方法中可以传入很多的类型:object、array、string、boolean、number、null 等，它们会被转换成 json 格式返回;
- status 方法

用于设置状态码：`res.status(200)`

```js
const express = require("express");
const router = require("./routers/users");

const app = express();

app.get("/products/:id/:name", (req, res, next) => {
  console.log(req.params);
  // req.params => 在数据库中查询真实的商品数据
  res.end("商品的详情数据~");
});

app.get("/login", (req, res, next) => {
  console.log(req.query);

  // 设置响应吗
  res.status(204);

  // res.type("application/json");
  // res.end(JSON.stringify({name: "why", age: 18}));
  // res.json({name: "why", age: 18})
  // 设置内容
  res.json(["abc", "cba", "abc"]);
});

/**
 * 举个例子:
 *   请求所有的用户信息: get /users
 *   请求所有的某个用户信息: get /users/:id
 *   请求所有的某个用户信息: post /users body {username: passwod:}
 *   请求所有的某个用户信息: delete /users/:id
 *   请求所有的某个用户信息: patch /users/:id {nickname: }
 */

app.listen(8000, () => {
  console.log("普通中间件服务器启动成功~");
});
```

- 更多响应的方式:https://www.expressjs.com.cn/4x/api.html#res

* [Express 的 res.send() 和 res.end()](https://juejin.cn/post/7055507463239368740)
* [Express](https://juejin.cn/post/7052369173535522829)

### 静态服务器和错误处理

Node 也可以作为静态资源服务器，并且 express 给我们提供了方便部署静态资源的方法

```js
// 静态资源部署
const express = require("express");

const app = express();

app.use(express.static("./build"));

app.listen(8000, () => {
  console.log("路由服务器启动成功~");
});
```

错误处理：

express 错误处理
在 express 中, 错误处理中间件是一个函数, 可以接收 4 个参数

- err: 错误对象
- req: 请求对象
- res: 响应对象
- next: 下一个中间件

在错误处理中间件中, 可以通过 err.message 来判断错误类型
在错误处理中间件中, 可以通过 res.status()来设置响应状态码
在错误处理中间件中, 可以通过 res.json()来设置响应数据
在错误处理中间件中, 可以通过 next()来跳过当前中间件, 继续执行下一个中间件
在错误处理中间件中, 可以通过 next(new Error())来跳过当前中间件, 继续执行下一个中间件, 并且设置错误状态码

```js
const express = require("express");

const app = express();

const USERNAME_DOES_NOT_EXISTS = "USERNAME_DOES_NOT_EXISTS";
const USERNAME_ALEARDY_EXISTS = "USERNAME_ALEARDY_EXISTS";

app.post("/login", (req, res, next) => {
  // 加入在数据中查询用户名时, 发现不存在
  const isLogin = false;
  if (isLogin) {
    res.json("user login success~");
  } else {
    //next 传参就是一个错误处理，会来到错误处理中间件来做处理错误 message
    next(new Error(USERNAME_DOES_NOT_EXISTS));
  }
});

app.post("/register", (req, res, next) => {
  // 加入在数据中查询用户名时, 发现不存在
  const isExists = true;
  if (!isExists) {
    res.json("user register success~");
  } else {
    next(new Error(USERNAME_ALEARDY_EXISTS));
  }
});

app.use((err, req, res, next) => {
  let status = 400;
  let message = "";
  console.log(err.message);

  switch (err.message) {
    case USERNAME_DOES_NOT_EXISTS:
      message = "username does not exists~";
      break;
    case USERNAME_ALEARDY_EXISTS:
      message = "USERNAME_ALEARDY_EXISTS~";
      break;
    default:
      message = "NOT FOUND~";
  }

  res.status(status);
  res.json({
    errCode: status,
    errMessage: message,
  });
});

app.listen(8000, () => {
  console.log("路由服务器启动成功~");
});
```

## koa

koa 注册的中间件提供了两个参数：

- ctx：上下文(Context)对象；
  - koa 并没有像 express 一样，将 req 和 res 分开，而是将它们作为 ctx 的属性；
  - ctx 代表依次请求的上下文对象；
    - ctx.request:获取请求对象；
    - ctx.response:获取响应对象；
- next：本质上是一个 dispatch，类似于之前的 next；

### 中间件

koa 通过创建的 app 对象，注册中间件只能通过 use 方法：Koa 并没有提供 methods 的方式来注册中间件（`app.get()`），也没有提供 path 中间件来匹配路径（`app.use("/",(req,res,next)=>{})`）。

```js
const Koa = require("koa");

const app = new Koa();

// use注册中间件
app.use((ctx, next) => {
  if (ctx.request.url === "/login") {
    if (ctx.request.method === "GET") {
      console.log("来到了这里~");
      ctx.response.body = "Login Success~";
    }
  } else {
    ctx.response.body = "other request~";
  }
});

app.use(() => {
  console.log("结束了");
});
// 没有提供下面的注册方式
// methods方式: app.get()/.post
// path方式: app.use('/home', (ctx, next) => {})
// 连续注册: app.use((ctx, next) => {
// }, (ctx, next) => {
// })

app.listen(8000, () => {
  console.log("koa初体验服务器启动成功~");
});
```

```
koa 初体验服务器启动成功~
来到了这里~
结束了
```

### 路由

koa 官方并没有给我们提供路由的库，我们可以选择第三方库：koa-router

```shell
npm install koa-router
```

我们可以先封装一个 user.router.js 的文件，在 app 中将 `router.routes()` 注册为中间件。

注意:allowedMethods 用于判断某一个 method 是否支持：

- 如果我们请求 get，那么是正常的请求，因为我们有实现 get；
- 如果我们请求 put、delete、patch，那么就自动报错：Method Not Allowed，状态码:405；
- 如果我们请求 link、copy、lock，那么就自动报错：Not Implemented（未实现），状态码:501；

```js
const Koa = require("koa");

const userRouter = require("./router/user");

const app = new Koa();

app.use((ctx, next) => {
  // ctx.response.body = "Hello World";
  next();
});

app.use(userRouter.routes());
app.use(userRouter.allowedMethods());

app.listen(8000, () => {
  console.log("koa路由服务器启动成功~");
});

// ./router/user.js
const Router = require("koa-router");

const router = new Router({ prefix: "/users" });

router.get("/", (ctx, next) => {
  ctx.response.body = "User Lists~";
});

router.put("/", (ctx, next) => {
  ctx.response.body = "put request~";
});

module.exports = router;
```

### 参数解析

```shell
npm install koa-bodyparser
```

```js
const Koa = require("koa");

const app = new Koa();
const Router = require("koa-router");

const userRouter = new Router({ prefix: "/users" });

userRouter.get("/:id", (ctx, next) => {
  console.log(ctx.request.params); // { id: '1' }
  console.log(ctx.request.query); // [Object: null prototype] { name: 'zhangsan', age: '18' }
});

// app.use((ctx, next) => {
//   console.log(ctx.request.url);
//   console.log(ctx.request.query);
//   console.log(ctx.request.params);
//   ctx.response.body = "Hello World";
// });

app.use(userRouter.routes());

app.listen(8000, () => {
  console.log("参数处理服务器启动成功~");
});
```

```
参数处理服务器启动成功~
{ id: '1' }
[Object: null prototype] { name: 'zhangsan', age: '18' }
```

```js
const Koa = require("koa");
const bodyParser = require("koa-bodyparser");

const app = new Koa();

app.use(bodyParser());

app.use((ctx, next) => {
  console.log(ctx.request.body); // { name: 'zhangsan', age: '18' }
  console.log(ctx.req.body); // undefined
  ctx.response.body = "Hello World";
});

app.listen(8000, () => {
  console.log("koa初体验服务器启动成功~");
});
```

```
koa 初体验服务器启动成功~
{ name: 'zhangsan', age: '18' }
undefined
```

### 响应内容

```js
const Koa = require("koa");

const app = new Koa();

app.use((ctx, next) => {
  // ctx.request.query
  // ctx.query

  // 设置内容
  // ctx.response.body
  // ctx.response.body = "Hello world~"
  // ctx.response.body = {
  //   name: "coderwhy",
  //   age: 18,
  //   avatar_url: "https://abc.png"
  // };
  // 设置状态码
  // ctx.response.status = 400;
  // ctx.response.body = ["abc", "cba", "nba"];

  // ctx.response.body = "Hello World~";
  ctx.status = 404;
  ctx.body = "Hello Koa~";
});

app.listen(8000, () => {
  console.log("koa初体验服务器启动成功~");
});
```

### 静态服务器和错误处理

```shell
npm install koa-static
```

```js
const Koa = require("koa");
const staticAssets = require("koa-static");

const app = new Koa();

// 静态资源文件夹
app.use(staticAssets("./build"));

app.listen(8000, () => {
  console.log("koa初体验服务器启动成功~");
});
```

错误处理：

```js
const Koa = require("koa");

const app = new Koa();

app.use((ctx, next) => {
  const isLogin = false;
  if (!isLogin) {
    // 抛出错误
    ctx.app.emit("error", new Error("您还没有登录~"), ctx);
  }
});

// 监听错误事件
app.on("error", (err, ctx) => {
  // 正式开发应该是 switch case
  ctx.status = 401;
  ctx.body = err.message;
});

app.listen(8001, () => {
  console.log("koa初体验服务器启动成功~");
});
```

## koa 对比 express

实际上 koa 和 express 从执行机制看都是所谓的洋葱模型，就是说每个中间件都有两次执行时机，用`next()`分隔：

我们先从一段代码来看这件事：

```js
// express版本
const express = require("express");
const app = new express();
// 中间件1
app.use((req, res, next) => {
  console.log("中间件1 start");
  next();
  console.log("中间件1 end");
  res.json({
    result: "中间件1",
  });
});

// 中间件2
app.use((req, res, next) => {
  console.log("中间件2 start");
  next();
  console.log("中间件2 end");
  res.json({
    result: "中间件2",
  });
});
// 中间件3
app.use((req, res, next) => {
  console.log("中间件3 start");
  res.json({
    result: "中间件3",
  });
  console.log("中间件3 end");
});
app.listen(8000, () => {
  console.log("server is running");
});
```

中间件 1 start
中间件 2 start
中间件 3 start
中间件 3 end
中间件 2 end
中间件 1 end

并且会报一个错：

```text
Cannot set headers after they are sent to the client
```

express 服务浏览器收到响应：`{"result":"中间件3"}`

koa 版本的：

```js
const koa = require("koa");
const app = new koa();
// 中间件1
app.use(async (ctx, next) => {
  console.log("中间件1 start");
  await next();
  console.log("中间件1 end");
  ctx.body = {
    result: "中间件1",
  };
});

// 中间件2
app.use(async (ctx, next) => {
  console.log("中间件2 start");
  await next();
  console.log("中间件2 end");
  ctx.body = {
    result: "中间件2",
  };
});

// 中间件3
app.use(async (ctx, next) => {
  console.log("中间件3 start");
  console.log("中间件3 end");
  ctx.body = {
    result: "中间件3",
  };
});

app.listen(8000, () => {
  console.log("server is running");
});
```

输出：
中间件 1 start
中间件 2 start
中间件 3 start
中间件 3 end
中间件 2 end
中间件 1 end

koa 服务浏览器接收到响应`{"result":"中间件 1"}`

### 分析

在 koa 的中间件模型中，当一个请求到来的时候，请求流会按照中间件注册的顺序，首先进入第一个注册的中间件，当第一个中间件处理完请求流的时候，其有两个选择，1 是直接响应结束请求，2 是调用 next 方法， 该函数暂停并将控制传递给定义的下一个中间件。当在下游没有更多的中间件执行后，**堆栈将展开并且每个中间件恢复执行其上游行为**。

即是说，koa 中间件在响应的时候，会从最后的一个中间件开始返回，到最开始的的中间件结束响应，并返回给客户端，其中返回的内容取决于洋葱模型中最靠近外层的响应结果。

所以在上述的例子中，虽然每个中间件都响应了数据，但由于响应会从第三个中间件往外发出，到第一个中间件的时候，响应 res.body 被改成了中间件 1 的数据。所以浏览器端接受到的数据为：`{"result":"中间件 1"}`

- 外部请求会根据中间件注册的顺序依次流入中间件(前提的上一个中间件调用了 next)
- 当前中间件的 ctx 参数，是经过上一个中间件(如果有的话)，处理过的参数。
- 请求的响应会从请求到达最内层中间件依次向外层中间件流过

express 中间件在某个中间件在调用 next 的时候，会将执行权交给下一个中间件(如果有的话)，和 koa 不同的是：

- express 的中间件主要基于循环匹配回调的方式（底层是同步实现的）
- express 响应流方式不一样，同一请求只能有一个响应出口，也就是只能有一个中间件对请求做出响应，所以响应的结果却决于第一个对请求做出响应的结果(这也是例子中为何会输出)：

### 实现

本质上的不同在于 next 的实现：

koa 的 next 是巧妙的使用了 Promise 特性。洋葱模型，本质上是 Promise.resolve()的递归。

当我们用 app.use 的时候，只是把中间件存在了一个数组里。

dispatch 函数，它将遍历整个 middleware，然后将 context 和 dispatch(i + 1)传给 middleware 中的方法。

dispatch return Promise 这段代码就很巧妙的实现了两点:

- 将 context 一路传下去给中间件
- 将 middleware 中的下一个中间件 fn 作为未来 next 的返回值

```js
function compose(middleware) {
  return function (context, next) {
    // last called middleware #
    let index = -1;
    return dispatch(0);

    function dispatch(i) {
      if (i <= index)
        return Promise.reject(new Error("next() called multiple times"));
      index = i;
      // 这里取出中间件
      let fn = middleware[i];
      if (i === middleware.length) fn = next;
      if (!fn) return Promise.resolve();
      try {
        // 核心代码：返回Promise
        // next时，交给下一个dispatch（下一个中间件方法）
        // 同时，当前同步代码挂起，直到中间件全部完成后继续
        return Promise.resolve(
          // 这里执行中间件并且将 middleware 中的下一个中间件 fn 返回作为未来 next
          fn(context, function next() {
            // 返回下一个 next 中间件
            return dispatch(i + 1);
          })
        );
      } catch (err) {
        return Promise.reject(err);
      }
    }
  };
}
```

而 express：express 中间件处理的过程是当有请求到来时，会根据路径来遍历中间件列表（一个 while 循环），依次找出合适的中间件进行处理，同时再执行中间件处理逻辑时，传入触发执行下一个中间件的 next 函数，只有调用 next 方法时，才会继续取出下一个匹配的中间件执行。

### 总结

对于 koa 和 express 中间件，其主要以下的不同点：

1. 中间件串联调用方式不同
   koa 基于函数栈调用方式，express 基于循环匹配查找并执行调方法（本质上也是函数调用栈），只不过 express 的 next 实现本质上是同步的，koa 的实现依靠 promise，koa 的返回值是 promise，所以 koa 可以依靠 async/await 做一些事情，所以在异步执行中间件时，Express 并非严格按照洋葱模型执行中间件，而 KOA 则是严格遵循的（async/awaits）（体现再两者在中间件为异步函数的时候处理会有不同）。

2. 响应规则不同
   koa 可以在每个中间件执行响应数据写入，而只有最后一个写入的才会最终返回给客户端，express 只能有一个中间件进行响应，多个中间件响应后会报错(所以中间件响应后，最好调用 return 确保结束处理请求)
